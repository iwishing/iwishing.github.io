<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>spring框架的概述以及spring中基于xml的IOC配置</title>
      <link href="/2020/04/10/spring%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
      <url>/2020/04/10/spring%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="一-spring框架的概述以及spring中基于xml的IOC配置"><a href="#一-spring框架的概述以及spring中基于xml的IOC配置" class="headerlink" title="一.spring框架的概述以及spring中基于xml的IOC配置"></a><font size="36">一.spring框架的概述以及spring中基于xml的IOC配置</font></h1><blockquote><p>环境：<br>Idea：2019.3.1<br>系统：windows10 家庭版<br>Jdk: 8<br>spring：5.0.3 release<br><a href="https://spring.io/projects/spring-framework" target="_blank" rel="noopener">spring文档</a><br><a href="https://github.com/iwishing/springStudyDemo" target="_blank" rel="noopener">项目代码</a></p></blockquote><h2 id="1-spring的概述"><a href="#1-spring的概述" class="headerlink" title="1.spring的概述"></a>1.spring的概述</h2><h3 id="spring是什么"><a href="#spring是什么" class="headerlink" title="spring是什么"></a>spring是什么</h3><p>   spring是分层的Java SE/EE应用<strong>full-stack</strong>轻量级开源框架，以<strong>IOC(Inverse Of Control:反转控制)</strong>和<strong>AOP(Aspect Oriented Programming:面向切面编程)</strong> 为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。</p><h3 id="spring的发展历程和优势"><a href="#spring的发展历程和优势" class="headerlink" title="spring的发展历程和优势"></a>spring的发展历程和优势</h3><h6 id="发展历程："><a href="#发展历程：" class="headerlink" title="发展历程："></a>发展历程：</h6><pre><code>1997年IBM提出了EJB的思想1998年，SUN制定开发标准规范EJB1.01999年，EJB1.1发布2001年，EJB2.0发布2003年，EJB2.1发布2006年，EJB3.0发布Rod Johnson(spring之父)    Expert One-to-One J2EE Design and Development(2002)    阐述了J2EE使用EJB开发设计的优点及解决方案    Expert One-to-One J2EE Development without EJB(2004)    阐述了J2EE开发不使用EJB的解决方式(Spring雏形)2017年9月份发布了spring的最新版本spring 5.0通用版(GA)</code></pre><h6 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h6><pre><code>--方便解耦，简化开发    通过Spring提供的IOC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。--AOP编程的支持    通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。--声明式事务的支持    可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。--方便程序的测试    可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。--方便集成各种优秀框架    Spring可以降低各种框架的使用难度，提供了对各种优秀框架(Struts、Hibernate、Hessian、Quartz等)的直接支持--降低JavaEE API的使用难度    Spring对JavaEE API(如JDBC、JavaMain、远程调用等)进行了薄薄的封装层，使这些API的使用难度大为降低--Java源码是经典学习范例    Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无疑是Java技术的最佳实践的范例。</code></pre><h3 id="spring体系结构"><a href="#spring体系结构" class="headerlink" title="spring体系结构"></a>spring体系结构</h3><p><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200309101317646.png" alt></p><h2 id="2-程序的耦合以及解耦"><a href="#2-程序的耦合以及解耦" class="headerlink" title="2.程序的耦合以及解耦"></a>2.程序的耦合以及解耦</h2><h3 id="程序的耦合"><a href="#程序的耦合" class="headerlink" title="程序的耦合"></a>程序的耦合</h3><pre><code>耦合：程序间的依赖关系， 类之间的依赖， 方法之间的依赖解耦：降低程序间的依赖关系实际开发中：   应该做到，编译器不依赖，运行时才依赖解耦的思路：   第一步：使用反射创建对象，而避免使用new创建对象（如mysql驱动，这又会产生一个问题，这个字符串是写死的，如果后来要修改数据库驱动，就很麻烦）   第二部：通过读取配置文件来获取要创建的对象的全限定名，唯一标识符=全限定类名（key==value）格式，配置文件可以是xml，也可以是properties</code></pre><h2 id="3-IOC概念和spring中的IOC"><a href="#3-IOC概念和spring中的IOC" class="headerlink" title="3.IOC概念和spring中的IOC"></a>3.IOC概念和spring中的IOC</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>常规创建对象方式:自主创建对象，通过new关键字，获取资源创建对象<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200309101406235.png" alt><br>被动接受获取对象：通过一个工厂对资源进行分配，程序只能被动接受对象，这就叫控制反转（IoC）<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200309101420402.png" alt></p><h5 id="Ioc的作用"><a href="#Ioc的作用" class="headerlink" title="Ioc的作用"></a>Ioc的作用</h5><pre><code>  削减计算机程序的耦合（解除我们代码中的依赖关系）   </code></pre><h3 id="spring中的IoC"><a href="#spring中的IoC" class="headerlink" title="spring中的IoC"></a>spring中的IoC</h3><p>sipring的开发包<a href="https://repo.spring.io/release/org/springframework/spring/" target="_blank" rel="noopener">Spring仓库</a></p><h5 id="spring对bean的管理细节（applicationContext-xml）"><a href="#spring对bean的管理细节（applicationContext-xml）" class="headerlink" title="spring对bean的管理细节（applicationContext.xml）"></a>spring对bean的管理细节（applicationContext.xml）</h5><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!--    把对象的创建交给spring来管理--&gt;&lt;!--spring对bean的管理细节：    1.创建bean对象的三种方式        第一种方式：使用默认构造函数创建            在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时。             采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。             意思就是，如果你在这个bean类里面写了个带参构造方法，而没有空参构造方法，那么就会报错             例子：             &lt;bean id=&quot;accountService&quot; class=&quot;com.cbw.service.impl.AccountServiceImpl&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;         第二种方式：使用普通工厂中的方法创建对象            使用某个类中的方法创建对象，并存入spring容器，意思就是，可能有个Factory类，他有个方法是            return一个AccountServiceImpl，即你需要的实现类            (1)先获取一个工厂的Bean对象            (2)通过factory-bean（用我们刚刚获取的工厂对象），factory-method（指明哪个方法）两个属性获取我们所需的Bean对象            例子：            &lt;bean id=&quot;instanceFactory&quot; class=&quot;com.cbw.Factory.InstanceFactory&quot;&gt;&lt;/bean&gt;            &lt;bean id=&quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;        第三种方式：使用工厂中的静态方法创建对象            使用某个类中的静态方法创建对象，并存入spring容器            class属性写那个静态工厂的全限定类名，factory-method写那个静态方法            例子：            &lt;bean id=&quot;accountService&quot; class=&quot;com.cbw.Factory.StaticFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;    2.bean对象的作用范围        bean标签的scope属性：            作用：用于指定bean的作用范围            取值：常用的就是单例的，多例的                singleton：单例的（默认值）                prototype：多例的                request：作用于web应用的请求范围                session：作用于web应用的会话范围                global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session（4.0版本的特性，5.0版本已不支持）    3.bean对象的生命周期        单例对象            出生：当容器创建，对象出生            活着：只要容器还在，对象一直活着            死亡：容器销毁，对象消亡            总结：单例对象的生命周期和容器相同        多例对象            出生：当我们使用对象时spring为我们创建            活着：对象只要是在使用中，就一直活着            死亡：当对象长时间不用，且没有别的对象引用时，由java垃圾回收器回收      例子：          &lt;bean id=&quot;accountService&quot; class=&quot;com.cbw.service.impl.AccountServiceImpl&quot; scope=&quot;prototype&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;&lt;/bean&gt;    --&gt;&lt;/beans&gt;</code></pre><h6 id="小插曲：global-session"><a href="#小插曲：global-session" class="headerlink" title="小插曲：global-session"></a>小插曲：global-session</h6><p><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200309101452231.png" alt></p><h5 id="获取IoC核心容器（client）"><a href="#获取IoC核心容器（client）" class="headerlink" title="获取IoC核心容器（client）"></a>获取IoC核心容器（client）</h5><pre><code>package com.cbw.ui;import com.cbw.dao.IAccountDao;import com.cbw.service.IAccountService;import com.sun.org.apache.xml.internal.utils.XML11Char;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.Resource;  auther:iwishing 获取spring的IoC容器，并根据id获取对象  ApplicationContext的三个常用实现类       ClassPathXmlApplicationContext：它可以加载类路径下的xml文件，要求配置文件必须在类路径下，否则加载不了(实际开发更常用)       FileSystemXmlApplicationContext：它可以加载磁盘任意路径下的配置文件，前提是有访问权限       AnnotationConfigApplicationContext：它是用于读取注解创建容器  ApplicationContext和BeanFactory的区别       ApplicationContext：--------------单例对象适用（一创建就存进去），开发时常用           它在构建核心容器时，创建对象采取的策略是采用立即加载的方式。也就是说，只要一读取完配置文件马上就创建配置文件           中配置的对象           测试方法：给对象添加一个构造函数，里面打印一句语句，然后yogaApplicationContext构造容器的时候可以看到这条语句打印出来了       BeanFactory：--------------多例对象适用（即用即创），顶层接口，功能没有子接口完善，故开发常使用上个接口           它在构建核心容器时，创建对象采取的策略是采用延迟加载的方式。也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象public class Client {    public static void main(String[] args) {  //ApplicationContext接口       //1.通过ClassPathXmlApplicationContext实现类获取核心容器对象        //ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //通过FileSystemXmlApplicationContext实现类获取核心容器对象        ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;E:\\myCodeSpace\\mySpringDemo\\mySpringDemo_spring\\src\\main\\resources\\applicationContext.xml&quot;);        //2.根据id获取bean对象        //根据唯一标识符，获取object对象再强转        IAccountService as = (IAccountService)ac.getBean(&quot;accountService&quot;);        //根据字节码自己强转        IAccountDao ad = ac.getBean(&quot;accountDao&quot;,IAccountDao.class);        as.saveAccount();     //BeanFactory接口        //1.通过ClassPathResource实现类找到配置文件        Resource resource = new ClassPathResource(&quot;applicationContext.xml&quot;);        //2.通过XmlBeanFactory实现类构建容器        BeanFactory beanFactory = new XmlBeanFactory(resource);        //3.通过id创建bean对象        IAccountService as = (IAccountService) beanFactory.getBean(&quot;accountService&quot;);        as.saveAccount();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通知类型，基于注解的AOP</title>
      <link href="/2020/04/10/spring%E5%AD%A6%E4%B9%A0(%E4%BA%94)/"/>
      <url>/2020/04/10/spring%E5%AD%A6%E4%B9%A0(%E4%BA%94)/</url>
      
        <content type="html"><![CDATA[<h1 id="通知类型，基于注解的AOP"><a href="#通知类型，基于注解的AOP" class="headerlink" title="通知类型，基于注解的AOP"></a><font size="36">通知类型，基于注解的AOP</font></h1><blockquote><p>环境：<br>Idea：2019.3.1<br>系统：windows10 家庭版<br>Jdk: 8<br>spring：5.0.3 release<br><a href="https://spring.io/projects/spring-framework" target="_blank" rel="noopener">spring文档</a><br><a href="https://github.com/iwishing/springStudyDemo" target="_blank" rel="noopener">项目代码</a></p></blockquote><h3 id="一、通知类型"><a href="#一、通知类型" class="headerlink" title="一、通知类型"></a>一、通知类型</h3><h5 id="1-前置通知"><a href="#1-前置通知" class="headerlink" title="1.前置通知"></a>1.前置通知</h5><pre><code>作用：     切入点方法执行前执行标签：    &lt;aop:before&gt;&lt;/aop:before&gt;示例：    &lt;aop:before method=&quot;beforePrintLog&quot; pointcut=&quot;execution(public void com.cbw.service.impl.AccountServiceImpl.saveAccount())&quot;&gt;&lt;/aop:before&gt;</code></pre><h5 id="2-后置通知"><a href="#2-后置通知" class="headerlink" title="2.后置通知"></a>2.后置通知</h5><pre><code>作用：     切入点方法执行后执行标签：    &lt;aop:after-returning&gt;&lt;/aop:after-returning&gt;示例：    &lt;aop:after-returning method=&quot;afterReturningPrintLog&quot; pointcut=&quot;execution(public void com.cbw.service.impl.AccountServiceImpl.saveAccount())&quot;&gt;&lt;/aop:after-returning&gt;</code></pre><h5 id="3-异常通知"><a href="#3-异常通知" class="headerlink" title="3.异常通知"></a>3.异常通知</h5><pre><code>作用：     切入点方法异常时执行标签：    &lt;aop:after-throwing&gt;&lt;/aop:after-throwing&gt;示例：    &lt;aop:after-throwing method=&quot;afterThrowingPrintLog&quot; pointcut=&quot;execution(public void com.cbw.service.impl.AccountServiceImpl.saveAccount())&quot;&gt;&lt;/aop:after-throwing&gt;</code></pre><p><strong>注意：</strong>异常通知和后置通知同时只能有一个执行，能想到，如果后置通知执行了，就代表切入点方法没有问题，那么异常通知就不会执行，而如果切入点方法出现异常，那么异常通知就会执行，而此时不会执行到后置方法</p><h5 id="4-最终通知"><a href="#4-最终通知" class="headerlink" title="4.最终通知"></a>4.最终通知</h5><pre><code>作用：     不管切入点方法是否成功执行都会执行标签：    &lt;aop:after&gt;&lt;/aop:after&gt;示例：    &lt;aop:after method=&quot;afterPrintLog&quot; pointcut=&quot;execution(public void com.cbw.service.impl.AccountServiceImpl.saveAccount())&quot;&gt;&lt;/aop:after&gt;</code></pre><h5 id="5-环绕通知"><a href="#5-环绕通知" class="headerlink" title="5.环绕通知"></a>5.环绕通知</h5><pre><code>标签：    &lt;aop:around&gt;&lt;/aop:around&gt;示例：    &lt;aop:around method=&quot;aroundPrintLog&quot; pointcut=&quot;execution(public void com.cbw.service.impl.AccountServiceImpl.saveAccount())&gt;&lt;/aop:around&gt;</code></pre><p>这里要停顿下，我们这样配置了环绕通知后，运行切入点方法可以看到只有环绕通知执行了，而切入点方法没执行<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200403100902803.png" alt><br>这里我们对比一下我们之前写的动态代理增强的方法<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200403105114483.png" alt><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200331050343170.png" alt><br>可以明确地知道，动态代理的环绕通知中有明确的切入点方法的调用，而我们配置的环绕通知方法中没有<br><strong>解决方法：</strong><br>spring框架为我们提供了一个接口，ProceedingJoinPoint，该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。该接口可以作为环绕通知的方法参数，在程序执行时spring框架会为我们提供该接口的实现类供我们使用</p><pre><code>/* * rtValue：切入点方法的返回值*/    public Object aroundPrintLog(ProceedingJoinPoint pjp){        Object rtValue = null;        //明确调用切入点方法        try {            //得到方法执行所需参数            Object [] args = pjp.getArgs();            //明确调用业务层方法            rtValue = pjp.proceed(args);            return rtValue;        } catch (Throwable throwable) {            throwable.printStackTrace();        }        System.out.println(&quot;Logger类中的arountPrintLog方法开始执行&quot;);        return rtValue;    }</code></pre><p><strong>spring中的环绕通知：</strong><br>    它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式</p><h5 id="6-补充"><a href="#6-补充" class="headerlink" title="6.补充"></a>6.补充</h5><p>标签：<code>&lt;aop:pointcut&gt;&lt;/aop:pointcut&gt;</code></p><pre><code>作用：    可以将通知的pointcut表达式写在外边，就不会让通知标签太长影响阅读    此标签写在&lt;aop:aspect/&gt;标签内部，只能够该切面使用它也可以写在&lt;aop:aspect/&gt;外面，此时所有切面均可使用，但是它要在使用它的切面之前配置，不然会报错属性：    id：是point唯一标识    expression：pointcut表达式示例&lt;aop:aspect&gt;     &lt;aop:pointcut id=&quot;pc1&quot; expression=&quot;execution(public void com.cbw.service.impl.AccountServiceImpl.saveAccount())&quot;/&gt;     &lt;aop:before method=&quot;beforePrintLog&quot; pointcut-ref=&quot;pc1&quot;&gt;&lt;/aop:before&gt;&lt;/aop:aspect&gt;</code></pre><h3 id="二、基于注解的AOP"><a href="#二、基于注解的AOP" class="headerlink" title="二、基于注解的AOP"></a>二、基于注解的AOP</h3><h5 id="1-修改配置文件"><a href="#1-修改配置文件" class="headerlink" title="1.修改配置文件"></a>1.修改配置文件</h5><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        https://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/context        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!--配置spring创建容器的时候要扫描的包--&gt;&lt;context:component-scan base-package=&quot;com.cbw&quot;&gt;&lt;/context:component-scan&gt;&lt;!--配置spring开启注解AOP的支持--&gt;&lt;!--    写上就支持，不写就不支持，也就是spring默认不支持--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt;</code></pre><h5 id="2-配置Logger类"><a href="#2-配置Logger类" class="headerlink" title="2.配置Logger类"></a>2.配置Logger类</h5><ul><li>因为Logger类不是那三层的，所以我们就是用@Component注解</li><li>使用@Aspect注解，表明这是一个切面类<pre><code>/*** 用于记录日志的工具类，它里面提供了公共的代码*/@Component(&quot;logger&quot;)@Aspectpublic class Logger {</code></pre></li><li>用@Before注解前置通知<br>这5种注解的参数都是pointcut表达式<pre><code>  /**   * 前置通知   */  @Before(&quot;pct1()&quot;)  public void beforePrintLog(){      System.out.println(&quot;前置通知：Logger类中的printLog方法开始执行&quot;);  }</code></pre></li><li>用@AfterReturning注解后置通知</li></ul><pre><code> /**     * 后置通知     */    @AfterReturning(&quot;pct1()&quot;)    public void afterReturningPrintLog(){        System.out.println(&quot;后置通知：Logger类中的afterReturningPrintLog方法开始执行&quot;);    }</code></pre><ul><li>用@AfterThrowing注解异常通知</li></ul><pre><code>    /**     * 异常通知     */    @AfterThrowing(&quot;pct1()&quot;)    public void afterThrowingPrintLog(){        System.out.println(&quot;异常通知：Logger类中的afterThrowingPrintLog方法开始执行&quot;);    }</code></pre><ul><li>用@After注解最终通知</li></ul><pre><code>    /**     * 最终通知     */    @After(&quot;pct1()&quot;)    public void afterPrintLog(){        System.out.println(&quot;最终通知：Logger类中的afterPrintLog方法开始执行&quot;);    }</code></pre><ul><li>用@Around注解环绕通知</li></ul><pre><code>    @Around(&quot;pct1()&quot;)    public Object aroundPrintLog(ProceedingJoinPoint pjp){    }</code></pre><ul><li>用@Pointcut注解，提供pointcut表达式，前面通知注解参数就是填写这个方法的名称，()不能掉</li></ul><pre><code>    @Pointcut(&quot;execution(public void com.cbw.service.impl.AccountServiceImpl.saveAccount())&quot;)    private void pct1(){}</code></pre><ul><li>完整代码</li></ul><pre><code>import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;/** * 用于记录日志的工具类，它里面提供了公共的代码 */@Component(&quot;logger&quot;)@Aspectpublic class Logger {    @Pointcut(&quot;execution(public void com.cbw.service.impl.AccountServiceImpl.saveAccount())&quot;)    private void pct1(){}    /**     * 前置通知     */    @Before(&quot;pct1()&quot;)    public void beforePrintLog(){        System.out.println(&quot;前置通知：Logger类中的printLog方法开始执行&quot;);    }    /**     * 后置通知     */    @AfterReturning(&quot;pct1()&quot;)    public void afterReturningPrintLog(){        System.out.println(&quot;后置通知：Logger类中的afterReturningPrintLog方法开始执行&quot;);    }    /**     * 异常通知     */    @AfterThrowing(&quot;pct1()&quot;)    public void afterThrowingPrintLog(){        System.out.println(&quot;异常通知：Logger类中的afterThrowingPrintLog方法开始执行&quot;);    }    /**     * 最终通知     */    @After(&quot;pct1()&quot;)    public void afterPrintLog(){        System.out.println(&quot;最终通知：Logger类中的afterPrintLog方法开始执行&quot;);    }    /**     * 环绕通知     */    @Around(&quot;pct1()&quot;)    public Object aroundPrintLog(ProceedingJoinPoint pjp){        Object rtValue = null;        //明确调用切入点方法        try {            //得到方法执行所需参数            Object [] args = pjp.getArgs();            System.out.println(&quot;前置通知执行了.....&quot;);            //明确调用业务层方法            rtValue = pjp.proceed(args);            System.out.println(&quot;后置通知执行了.....&quot;);            return rtValue;        } catch (Throwable throwable) {            System.out.println(&quot;异常通知执行了.....&quot;);            throwable.printStackTrace();        }finally {            System.out.println(&quot;最终通知执行了.....&quot;);        }        System.out.println(&quot;Logger类中的arountPrintLog方法开始执行&quot;);        return rtValue;    }}</code></pre><h5 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h5><p>我们首先将环绕通知的注解注释掉，先测试前四种<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200405105933609.png" alt><br>可是，我们发现，最终通知却在后置通知前面执行，我们试试异常通知</p><ul><li>在saveAccount方法中加入int i=1/0;</li></ul><p><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200405110151452.png" alt><br>然后发现，异常通知还是在最终通知后面，这是为什么呢？<br>其实这是基于注解的springaop中确实存在的通知顺序问题，老版本的spring中并没有改良，至少我这个版本是这样的<br>虽然有这个问题，但是我们还是能使用环绕通知来解决的，环绕通知能够让我们自己决定通知的顺序，我们将前四个通知的注解注释掉，然后把环绕通知注解恢复，再执行saveAccount方法<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200405111213451.png" alt><br>可以看到，顺序没问题了</p><h5 id="4-纯注解方式"><a href="#4-纯注解方式" class="headerlink" title="4.纯注解方式"></a>4.纯注解方式</h5><pre><code>//他是一个bean对象@Component(&quot;logger&quot;)//他是一个切面对象@Aspect//扫描包@ComponentScan(&quot;com.cbw&quot;)//设置对注解支持@EnableAspectJAutoProxypublic class Logger {}</code></pre><p>再删除xml文件，别忘了，创建容器的方法修改成<br><code>ApplicationContext ac = new AnnotationConfigApplicationContext(Logger.class);</code><br>执行结果<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200406125519359.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP的概念与spring中的AOP</title>
      <link href="/2020/04/10/spring%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/"/>
      <url>/2020/04/10/spring%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/</url>
      
        <content type="html"><![CDATA[<h1 id="AOP的概念与spring中的AOP"><a href="#AOP的概念与spring中的AOP" class="headerlink" title="AOP的概念与spring中的AOP"></a><font size="36">AOP的概念与spring中的AOP</font></h1><blockquote><p>环境：<br>Idea：2019.3.1<br>系统：windows10 家庭版<br>Jdk: 8<br>spring：5.0.3 release<br><a href="https://spring.io/projects/spring-framework" target="_blank" rel="noopener">spring文档</a><br><a href="https://github.com/iwishing/springStudyDemo" target="_blank" rel="noopener">项目代码</a></p></blockquote><h3 id="一、AOP的概念"><a href="#一、AOP的概念" class="headerlink" title="一、AOP的概念"></a>一、AOP的概念</h3><h5 id="1-什么是AOP"><a href="#1-什么是AOP" class="headerlink" title="1.什么是AOP"></a>1.什么是AOP</h5><pre><code>AOP：全称是Aspect Oriented Programming，即面向切面编程</code></pre><p><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200331011412027.png" alt></p><pre><code>简单地说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理技术，在不需要修改源码的基础上，对我们的已有方法进行增强</code></pre><h5 id="2-AOP的作用及优势"><a href="#2-AOP的作用及优势" class="headerlink" title="2.AOP的作用及优势"></a>2.AOP的作用及优势</h5><pre><code>作用：    在程序运行期间，不修复源码的已有方法进行增强优势：    减少重复代码    提高开发效率    维护方便</code></pre><h5 id="3-AOP的实现方式"><a href="#3-AOP的实现方式" class="headerlink" title="3.AOP的实现方式"></a>3.AOP的实现方式</h5><pre><code>动态代理技术实现</code></pre><h3 id="二、spring中的AOP"><a href="#二、spring中的AOP" class="headerlink" title="二、spring中的AOP"></a>二、spring中的AOP</h3><h5 id="1-AOP相关术语"><a href="#1-AOP相关术语" class="headerlink" title="1.AOP相关术语"></a>1.AOP相关术语</h5><pre><code>Joinpoint(连接点)：    所谓连接点是指那些被拦截到的点，在spring中，这些点指的是方法，因为spring只支持方法类型的连接点。即业务层中被动态代理的类中所有的方法Pointout(切入点)：    所谓切入点是指我们要对哪些Joinpoint进行拦截的定义，即业务层中被动态代理的类中被增强了的方法Advice(通知/增强)：    所谓通知是指拦截到Joinpoint之后所要做的事情就是通知    通知的类型：前置通知，后置通知，异常通知，最终通知，环绕通知</code></pre><p><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200331050343170.png" alt></p><pre><code>Introduction(引介)：    所谓引介是指一种特殊的通知，在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法成FieldTarget(目标对象)：    代理的目标对象Weaving(织入)：    是指把增强应用到目标对象来创建新的代理对象的过程    spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入</code></pre><p><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200331111045039.png" alt></p><pre><code>Proxy(代理)：    一个类被AOP织入增强后，就产生了一个结果代理类，Target是被代理对象，而Proxy则是代理对象Aspect(切面)：    是切入点和通知（引介）的结合，很抽象，就是在织入的过程中，哪个service，哪些增强方法，这些方法何时执行，这就叫做切面</code></pre><h5 id="2-学习spring中的AOP要明确的事"><a href="#2-学习spring中的AOP要明确的事" class="headerlink" title="2.学习spring中的AOP要明确的事"></a>2.学习spring中的AOP要明确的事</h5><pre><code>a、开发阶段(我们做的)    编写核心业务代码(开发主线)：大部分程序员来做，要求熟悉业务需求。    把公用代码抽取出来，制作成通知(开发阶段最后再做)：AOP编程人员来做    在配置文件中，声明切入点与通知间的关系，即切面：AOP编程人员来做b、运行阶段(spring框架完成的)    spring框架监控切入点方法的执行，一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行</code></pre><h5 id="3-关于代理的选择"><a href="#3-关于代理的选择" class="headerlink" title="3.关于代理的选择"></a>3.关于代理的选择</h5><pre><code>在spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式</code></pre><h3 id="三、spring中基于xml的AOP"><a href="#三、spring中基于xml的AOP" class="headerlink" title="三、spring中基于xml的AOP"></a>三、spring中基于xml的AOP</h3><h5 id="1-导入坐标"><a href="#1-导入坐标" class="headerlink" title="1.导入坐标"></a>1.导入坐标</h5><p>除了之前的，我们再导入一个aspectj的jar包<br>idea中，再pom.xml文件中，直接alt+insert，然后选择Dependency，在出来的框里面搜索需要的包就能找到，还能选择版本</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.8.7&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h5 id="2-新建项目springAOP"><a href="#2-新建项目springAOP" class="headerlink" title="2.新建项目springAOP"></a>2.新建项目springAOP</h5><p>最终项目结构如下<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200401093826268.png" alt><br>业务层的AccountServiceImpl中的方法为我们所要增强的方法，即它是我们要用的切入点</p><h6 id="AccountServiceImpl类"><a href="#AccountServiceImpl类" class="headerlink" title="AccountServiceImpl类"></a>AccountServiceImpl类</h6><pre><code>import com.cbw.service.IAccountService;/** * 账户的业务层实现类 */public class AccountServiceImpl implements IAccountService {    /**     * 保存账户方法     */    public void saveAccount() {        System.out.println(&quot;执行了保存&quot;);    }    /**     * 更新账户方法     * @param i     */    public void updateAccount(int i) {        System.out.println(&quot;执行了更新&quot; + i);    }    /**     * 删除账户方法     * @return     */    public int deleteAccount() {        System.out.println(&quot;执行了删除&quot;);        return 0;    }}</code></pre><p>这3个方法都有各自的特点</p><pre><code>    saveAccount()方法：    无返回值，无参数    updateAccount()方法：  无返回值，有参数    deleteAccount()方法：  有返回值，无参数</code></pre><p>这样设置是为了在后面知识学习中有个对比</p><h6 id="Logger类"><a href="#Logger类" class="headerlink" title="Logger类"></a>Logger类</h6><p>它是用来提供切面中作为通知的方法的类，这里我们用打印日志作为前置通知，来增强service中的方法</p><pre><code>/** * 用于记录日志的工具类，它里面提供了公共的代码 */public class Logger {    /**     * 用于打印日志，计划让其在切入点方法执行之前执行(切入点方法就是业务层方法)     */    public void printLog(){        System.out.println(&quot;Logger类中的printLog方法开始执行&quot;);    }}</code></pre><h6 id="AopTest测试类"><a href="#AopTest测试类" class="headerlink" title="AopTest测试类"></a>AopTest测试类</h6><pre><code>import com.cbw.service.IAccountService;        import org.junit.Test;        import org.junit.runner.RunWith;        import org.springframework.beans.factory.annotation.Autowired;        import org.springframework.test.context.ContextConfiguration;        import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * 测试aop的配置是否成功 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)public class AopTest {    @Autowired    IAccountService accountService;    /**     * 测试存储账户方法     */    @Test    public void testSaveAccount(){        accountService.saveAccount();    }    /**     * 测试更新账户方法     */    @Test    public void testUpdateAccount(){        accountService.updateAccount(1);    }    /**     * 测试删除账户方法     */    @Test    public void testdeleteAccount(){        accountService.deleteAccount();    }}</code></pre><h5 id="3-applicationContext-xml中配置IOC和AOP"><a href="#3-applicationContext-xml中配置IOC和AOP" class="headerlink" title="3.applicationContext.xml中配置IOC和AOP"></a>3.applicationContext.xml中配置IOC和AOP</h5><h6 id="1-首先导入相关依赖"><a href="#1-首先导入相关依赖" class="headerlink" title="1.首先导入相关依赖"></a>1.首先导入相关依赖</h6><p>这个可以在文章开头的官方文档里，进Core technologies即core核心组件的文档中搜索xmlns:aop就能快速定位到</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;/bean&gt;</code></pre><h6 id="2-配置spring的ioc并且将bean对象加入容器"><a href="#2-配置spring的ioc并且将bean对象加入容器" class="headerlink" title="2.配置spring的ioc并且将bean对象加入容器"></a>2.配置spring的ioc并且将bean对象加入容器</h6><pre><code>&lt;!--把service对象配置进去--&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.cbw.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;&lt;!--配置Logger类，因为Logger类要在切入点方法之前执行，也就可以当作是前置通知--&gt;    &lt;bean id=&quot;Logger&quot; class=&quot;com.cbw.utils.Logger&quot;&gt;&lt;/bean&gt;</code></pre><h6 id="3-配置springAOP"><a href="#3-配置springAOP" class="headerlink" title="3.配置springAOP"></a>3.配置springAOP</h6><pre><code>·使用&lt;aop:config&gt;&lt;/aop:config&gt;标签表明开始AOP的配置·使用&lt;aop:aspect&gt;&lt;/aop:aspect&gt;标签表明开始配置切面，在&lt;aop:config&gt;&lt;/aop:config&gt;标签内部使用    属性：        id：是给切面提供一个唯一标识        ref属性：是指定通知类bean的id，即作为通知的方法所在的类的bean的id·在&lt;aop:aspect&gt;&lt;/aop:aspect&gt;标签内部使用不同的通知类型的标签来配置通知，这里我们先学前置通知，所用标签&lt;aop:before&gt;&lt;/aop:before&gt;    属性：        method：用于指定Logger类(即通知类)中哪个方法是前置通知        pointcut：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强        切入点表达式的写法：            关键字：execution(表达式)            表达式：访问控制符 返回值 包名.包名.包名...类名.方法名(参数列表)            标准的实例：                     增强com.cbw.service.impl包下的AccountServiceImpl类中的pulic void saveAccount()方法                 表达式：·                    public void com.cbw.service.impl.AccountServiceImpl.saveAccount()        注意：切入点表达式可以用通配符表示，最简洁的即全通配符                * *..*.*(..)            由标准表达式到全通配符变换过程如下            1.标准                public void com.cbw.service.impl.AccountServiceImpl.saveAccount()            2.访问修饰符可以省略                void com.cbw.service.impl.AccountServiceImpl.saveAccount()            3.返回值可以使用通配符*，表示任意返回值                * com.cbw.service.impl.AccountServiceImpl.saveAccount()            4.包名可以使用通配符，表示任意包，但是有几级包，就需要写几个                * *.*.*.*.AccountServiceImpl.saveAccount()            5.包名可以使用..表示当前包及其子包                * *..AccountServiceImpl.saveAccount()            6.类名和方法名都可以使用通配符*来实现统配                * *..*.*()            7.参数列表：(这里就体现了设置3个不同方法的用处)                基本类型直接写名称   如int                      * *..*.*(int)                引用类型写包名.类名  如java.lang.String                      * *..*.*(java.lang.String)                可以使用通配符*表示任意类型，但是一定得有参数                      * *..*.*(*)                可以使用..表示有无参数均可，有参数则表示任意参数                 * *..*.*(..)       &lt;------------------------------------这个即全通配符写法             8.注意，我们实际开发中不能这么写，因为这么写，所有的方法都会被增强，因为它全是*，所有方法都满足条件                 写法规则：切到业务层实现类下的所有方法                   即：* com.cbw.service.impl.*.*(..)</code></pre><p>配置好的是这样的</p><pre><code>        &lt;aop:config&gt;            &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;Logger&quot;&gt;                &lt;aop:before method=&quot;printLog&quot; pointcut=&quot;execution(* com.cbw.service.impl.AccountServiceImpl.*.*(..))&quot;&gt;&lt;/aop:before&gt;            &lt;/aop:aspect&gt;        &lt;/aop:config&gt;</code></pre><p>还有一个小知识点，切入点表达式的解析由aspectjweaver负责，下面这个东西</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h6 id="4-完整的文件内容"><a href="#4-完整的文件内容" class="headerlink" title="4.完整的文件内容"></a>4.完整的文件内容</h6><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;//配置所需bean，并加入IOC核心容器&lt;bean id=&quot;accountService&quot; class=&quot;com.cbw.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;Logger&quot; class=&quot;com.cbw.utils.Logger&quot;&gt;&lt;/bean&gt;//配置springAOP&lt;aop:config&gt;    &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;Logger&quot;&gt;         &lt;aop:before method=&quot;printLog&quot; pointcut=&quot;execution(* com.cbw.service.impl.*.*(..))&quot;&gt;&lt;/aop:before&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;/beans&gt;</code></pre><h6 id="5-测试类中的测试结果"><a href="#5-测试类中的测试结果" class="headerlink" title="5.测试类中的测试结果"></a>5.测试类中的测试结果</h6><p>testSaveAccount()方法<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200401112043869.png" alt><br>testUpdateAccount()方法<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200401112121817.png" alt><br>testDeleteAccount()方法<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200401112156314.png" alt><br><strong>总结：</strong>方法增强成功了，也就是springAOP配置成功了</p><h6 id="6-问题"><a href="#6-问题" class="headerlink" title="6.问题"></a>6.问题</h6><p>从上面一节应该可以发现一个问题，它的前置通知为什么输出了两次？我最初想的是可能是它的构造方法也给增强了<br>我就在AccountServiceImpl类中添加了无参构造方法，并加入一句话<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200401112515018.png" alt><br>然后我去执行testSaveAccount()方法<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200401112757950.png" alt><br>这里打印了构造方法中的语句，说明执行了构造方法，但是也不能说明构造方法被增强了，因为前置通知在构造方法的后面，按理说应该是不对的，然后我就想，会不会和bean的作用范围有关，毕竟bean的scope属性默认是sington，而sington类型的bean是在容器创建的时候就一起初始化了，而prototype类型的bean是在调用的时候才初始化的，抱着这个心态，我把accountService的scope设置成了prototype<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200401113344111.png" alt><br>再次执行testSaveAccount()方法<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200401113351837.png" alt><br>他顺序竟然对了，所以我暂时搞不懂，等查阅了相关资料再把这个问题弄明白</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务控制，动态代理，动态代理实现事务控制</title>
      <link href="/2020/04/10/spring%E5%AD%A6%E4%B9%A0(%E4%B8%89)/"/>
      <url>/2020/04/10/spring%E5%AD%A6%E4%B9%A0(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<h1 id="事务控制，动态代理，动态代理实现事务控制"><a href="#事务控制，动态代理，动态代理实现事务控制" class="headerlink" title="事务控制，动态代理，动态代理实现事务控制"></a><font size="36">事务控制，动态代理，动态代理实现事务控制</font></h1><blockquote><p>环境：<br>Idea：2019.3.1<br>系统：windows10 家庭版<br>Jdk: 8<br>spring：5.0.3 release<br><a href="https://spring.io/projects/spring-framework" target="_blank" rel="noopener">spring文档</a><br><a href="https://github.com/iwishing/springStudyDemo" target="_blank" rel="noopener">项目代码</a></p></blockquote><h3 id="一、事务控制"><a href="#一、事务控制" class="headerlink" title="一、事务控制"></a>一、事务控制</h3><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>操作账户的项目结构如下<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200330040823129.png" alt><br>正常流程是<br>首先创建一个账户业务层对象accountServiceImpl<br>再创建一个持久层对象accountDaoImpl<br>最后accountServiceImpl调用accountDao通过ConnectionUtils对象获取Conncetion连接，再执行操作，这就有个问题，按这种来写，如果有<strong>一个功能需要多条代码</strong>，例如，转账，A向B转账</p><pre><code>    /**     * 转账     * @param sourceName：转出账户名称     * @param targetName：转入账户名称     * @param money：转账金额     */ public void transfer(String sourceName, String targetName, Float money) {        try {            //1.根据名称查询转出账户            Account sourceAccount = accountDao.findAccountByName(sourceName);            //2.根据名称查询转入账户            Account targetAccount = accountDao.findAccountByName(targetName);            //3.转出账户减钱            sourceAccount.setMoney(sourceAccount.getMoney() - money);            //4.转入账户加钱            targetAccount.setMoney(targetAccount.getMoney() + money);            //5.更新转出账户            accountDao.updateAccount(sourceAccount);            //6.更新转入账户            accountDao.updateAccount(targetAccount);        }catch (Exception e){        }</code></pre><p>我们在这6条操作中加入一条<font color="red">int sum = 1/0</font></p><pre><code>            sourceAccount.setMoney(sourceAccount.getMoney() - money);            int sum = 1/0        &lt;--------------------------------------------------这里            //4.转入账户加钱            targetAccount.setMoney(targetAccount.getMoney() + money);</code></pre><p>执行程序后我们发现程序出错，转账失败，但是转出账户已经减钱了，这是因为这6条语句的事务都是相互独立的，后面语句出错也不会影响前面的事务在出错前已经提交了，我们要解决这个问题，就要将这些语句变成一个事务</p><h5 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h5><p>1、新建一个事务控制器类<strong>TransactionManager</strong><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200330042954376.png" alt><br>该类的内容如下</p><pre><code>import java.sql.SQLException;/** * 和事务相关的工具类，它包含了开启事务，提交事务，回滚事务，释放连接 */public class TransactionManager {    private ConnectionUtils connectionUtils;    /**     * 开始事务     */    public void beginTranscation(){        try {        //关闭事务的自动提交，即改为手动提交            connectionUtils.getThreadConnection().setAutoCommit(false);        } catch (SQLException e) {            e.printStackTrace();        }    }    /**     * 提交事务     */    public void commit(){        try {            connectionUtils.getThreadConnection().commit();        } catch (SQLException e) {            e.printStackTrace();        }    }    /**     * 回滚事务     */    public void rollback(){        try {            connectionUtils.getThreadConnection().rollback();        } catch (SQLException e) {            e.printStackTrace();        }    }    /**     * 释放连接     */    public void release(){        try {            connectionUtils.getThreadConnection().close();//并不是真的关闭，是将conn连接还回连接池中            connectionUtils.removeConnection();//解绑，将连接对象和线程解绑        } catch (SQLException e) {            e.printStackTrace();        }    }    public void setConnectionUtils(ConnectionUtils connectionUtils) {        this.connectionUtils = connectionUtils;    }}</code></pre><p>2、修改ConnectionUtils，用ThreadLoacl&lt;&gt;容器将Connection连接与当前线程绑定，要使一个线程中只有一个能控制事务的对象</p><pre><code>import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;/** * 连接的工具类，它用于从数据源中获取一个连接，并且实现和线程的绑定 */public class ConnectionUtils {    //threadlocal是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据    private ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;Connection&gt;();    //数据源    private DataSource dataSource;    /**    *获取connection对象    */    public Connection getThreadConnection(){        try {        //1.先从ThreadLocal上获取Connection对象        Connection conn = tl.get();        //2.判断当前线程上是否有连接        if(conn == null){            //3.从数据源中获取一个连接，并且存入ThreadLocal中            conn = dataSource.getConnection();            tl.set(conn);        }        //4.返回当前线程上的连接            return conn;    }catch (SQLException e){        throw new RuntimeException();    }    }    /**     * 将线程和连接解绑     */    public void removeConnection(){        tl.remove();    }    /**    *设置数据源    */    public void setDataSource(DataSource dataSource) {        this.dataSource = dataSource;    }}</code></pre><p>3、在业务层AccountServiceImpl中加入事务</p><pre><code>    public void transfer(String sourceName, String targetName, Float money) {        try {            //一.开启事务            transactionManager.beginTranscation();            //二.执行操作            //1.根据名称查询转出账户            Account sourceAccount = accountDao.findAccountByName(sourceName);            //2.根据名称查询转入账户            Account targetAccount = accountDao.findAccountByName(targetName);            //3.转出账户减钱            sourceAccount.setMoney(sourceAccount.getMoney() - money);            //4.转入账户加钱            targetAccount.setMoney(targetAccount.getMoney() + money);            //5.更新转出账户            accountDao.updateAccount(sourceAccount);            //6.更新转入账户            accountDao.updateAccount(targetAccount);            //三.提交事务            transactionManager.commit();            //四.返回结果        }catch (Exception e){            //五.回滚事务            transactionManager.rollback();        }finally {            //六.释放连接            transactionManager.release();        }    }</code></pre><p>将业务操作代码放在第二步，当业务操作代码出问题，事务不会提交，相反，一切正常，事务就会提交，这样就解决了之前的事务问题</p><h3 id="二、动态代理"><a href="#二、动态代理" class="headerlink" title="二、动态代理"></a>二、动态代理</h3><pre><code>特点：字节码随用随创建，随用随加载作用：不修改源码的基础上对方法增强分类：    1.基于接口的动态代理    2.基于子类的动态代理</code></pre><h5 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h5><pre><code>    1.涉及的类：        Proxy    2.提供者：        JDK官方    3.如何创建代理对象：        使用Proxy类中的newProxyInstance方法    4.创建基于接口的代理对象的要求：        被代理类最少实现一个接口，如果没有则不能使用    5.newProxyInstance方法参数：        ClassLoader：类加载器，用于加载代理对象字节码的，和被代理对象使用相同的类加载器,固定写法，类.getClass().getClassLoader();        Class[]：它是用于让代理对象和被代理对象有相同方法，固定写法，类.getClass().getInterfaces();        InvocationHandler：它是让我们写如何代理。我们一般都是写一些该接口的实现类，通常情况下都是匿名内部类，但不是必须的，此接口的实现类都是谁用谁写        Proxy.newProxyInstance(producer.getClass().getClassLoader(), producer.getClass().getInterfaces(), new InvocationHandler(){        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {}        }）</code></pre><h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><p>proxy类直接导入使用即可</p><h6 id="Producer接口"><a href="#Producer接口" class="headerlink" title="Producer接口"></a>Producer接口</h6><pre><code>/** * 对生产厂家要求的接口 */public interface IProducer {    /**     * 销售     * @param money     *     */    public void saleProduct(float money);    /**     * 售后     * @param money     */    public void afterService(float money);}</code></pre><h6 id="Producer类"><a href="#Producer类" class="headerlink" title="Producer类"></a>Producer类</h6><pre><code>/** * 一个生产者 */public class Producer implements IProducer{    /**     * 销售方法     * @param money     *     */    public void saleProduct(float money){        System.out.println(&quot;销售产品,拿到钱：&quot;+money);    }    /**     * 售后方法     * @param money     */    public void afterService(float money){        System.out.println(&quot;提供售后服务，拿到钱：&quot; + money);    }}</code></pre><h6 id="测试类Client"><a href="#测试类Client" class="headerlink" title="测试类Client"></a>测试类Client</h6><pre><code>import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * 模拟一个消费着 */public class Client {    public static void main(String[] args) {        //创建一个生产商        final Producer producer = new Producer();        IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(), producer.getClass().getInterfaces(), new InvocationHandler() {            /**             *             * 作用：执行被代理对象的任何接口方法都会经过该方法             * 参数：             * @param proxy 代理对象的引用             * @param method 当前执行的方法             * @param args 当前执行方法所需参数             * @return 和被代理对象具有相同返回值             * @throws Throwable             */            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                //这里进行方法增强，比如，这里我们可以抽取部分提成                Object returnValue = null;                //1.获取方法执行的参数                Float money = (Float)args[0];                //2.判断当前方法是不是销售                if(&quot;saleProduct&quot;.equals(method.getName())){                    //提成20%                    returnValue = method.invoke(producer,money*0.8f);                }                return returnValue;            }        });        proxyProducer.saleProduct(10000f);    }}</code></pre><p>运行结果<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200329042850822.png" alt></p><h5 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h5><pre><code>    1.涉及的类：        Enhancer    2.提供者：        第三方cglib库    3.如何创建代理对象：        使用Enhancer类中的create方法    4.创建基于子类的代理对象的要求：        被代理对象不能是最终类    5.create方法参数：        Class：字节码，用于指定被代理对象的字节码，固定写法，类.getClass()        Callback：用于让我们写如何代理，一般写一个该接口的实现类，常用MethodInterceptor，通常情况下都是写匿名内部类，但不是必须的，谁用谁写        Enhancer.create(producer.getClass(), new MethodInterceptor() {        @Override        public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {         }    });</code></pre><h6 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h6><p>首先导入Enhancer类所需cglib库的坐标</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;cglib&lt;/groupId&gt;            &lt;artifactId&gt;cglib&lt;/artifactId&gt;            &lt;version&gt;2.2.2&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h6 id="Producer类-1"><a href="#Producer类-1" class="headerlink" title="Producer类"></a>Producer类</h6><pre><code>package com.cbw.cglib;/** * 一个生产者 */public class Producer {    /**     * 销售     * @param money     *     */    public void saleProduct(float money){        System.out.println(&quot;销售产品,拿到钱：&quot;+money);    }    /**     * 售后     * @param money     */    public void afterService(float money){        System.out.println(&quot;提供售后服务，拿到钱：&quot; + money);    }}</code></pre><h6 id="测试类Client-1"><a href="#测试类Client-1" class="headerlink" title="测试类Client"></a>测试类Client</h6><pre><code>package com.cbw.cglib;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * 模拟一个消费着 */public class Client {    public static void main(String[] args) {        final Producer producer = new Producer();        /*        *动态代理：        *   特点：字节码随用随创建，随用随加载        *   作用：不修改源码的基础上对方法增强        *   分类：        *       1.基于接口的动态代理        *       2.基于子类的动态代理        * 这里我们使用基于子类的动态代理：        *       涉及的类：Enhancer        *       提供者：第三方cglib库        * 学习过程：        *       1.如何创建代理对象：        *           使用Enhancer类中的create方法        *       2.创建代理对象的要求：        *           被代理对象不能是最终类        *       3.create方法参数：        *           Class：字节码，用于指定被代理对象的字节码，固定写法，类.getClass()        *           Callback：用于让我们写如何代理，一般写一个该接口的实现类，常用MethodInterceptor，通常情况下都是写匿名内部类，但不是必须的，谁用谁写         */        Producer proxyProducer = (Producer) Enhancer.create(producer.getClass(), new MethodInterceptor() {            @Override            public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {                //这里进行方法增强，比如，这里我们可以抽取部分提成                Object returnValue = null;                //1.获取方法执行的参数                Float money = (Float)args[0];                //2.判断当前方法是不是销售                if(&quot;saleProduct&quot;.equals(method.getName())){                    returnValue = method.invoke(producer,money*0.8f);                }                return returnValue;            }        });        proxyProducer.saleProduct(10000f);    }}</code></pre><p>运行结果<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200330033635030.png" alt><br>AccountServiceImpl是之前事务所用到的，所以里面每个方法都套了一遍事务<br>而AccountServiceImpl_new则是无添加事务的普通service，我们使用这个，然后其他文件照旧</p><h3 id="三、动态代理实现事务控制"><a href="#三、动态代理实现事务控制" class="headerlink" title="三、动态代理实现事务控制"></a>三、动态代理实现事务控制</h3><p>我们使用基于接口的动态代理，项目结构如下<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200330111443944.png" alt></p><h4 id="1、在之前事务的项目下新建BeanFactory类，这是创建service代理对象的工厂，我们使用动态代理将事务放在代理对象的增强方法invoke中"><a href="#1、在之前事务的项目下新建BeanFactory类，这是创建service代理对象的工厂，我们使用动态代理将事务放在代理对象的增强方法invoke中" class="headerlink" title="1、在之前事务的项目下新建BeanFactory类，这是创建service代理对象的工厂，我们使用动态代理将事务放在代理对象的增强方法invoke中"></a>1、在之前事务的项目下新建<strong>BeanFactory类</strong>，这是创建service代理对象的工厂，我们使用动态代理将事务放在代理对象的增强方法invoke中</h4><pre><code>import com.cbw.service.IAccountService;import com.cbw.utils.TransactionManager;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * 用于创建service的代理对象的工厂 */public class BeanFactory {    //accountService对象    private IAccountService accountService;    //事务管理器对象    private TransactionManager transactionManager;    /**     * 用于注入transactionManager的set方法     * @param transactionManager     */    public final void setTransactionManager(TransactionManager transactionManager) {        this.transactionManager = transactionManager;    }    /**     * 用于注入accountService的set方法     * @param accountService     */    public final void setAccountService(IAccountService accountService) {        this.accountService = accountService;    }    /**     * 获取service代理对象的方法     * @return     */    public IAccountService getAccountService(){       return  (IAccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(), accountService.getClass().getInterfaces(), new InvocationHandler() {            /**             * 添加事务的支持             * @param proxy             * @param method             * @param args             * @return             * @throws Throwable             */            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                Object rtValue = null;                try {                    //1.开启事务                    transactionManager.beginTranscation();                    //2.执行操作                    rtValue = method.invoke(accountService,args);                    //3.提交事务                    transactionManager.commit();                    //4.返回结果                    return rtValue;                }catch (Exception e){                    //5.回滚事务                    transactionManager.rollback();                }finally {                    //6.释放连接                    transactionManager.release();                }                return rtValue;            }        });    }}</code></pre><p>根据上面事务和动态代理的知识，不难理解这个类。<br>这个类有一个核心方法，就是<strong>getAccountService()</strong> ，用于获取accountService的代理对象，这里简写了，直接return (IAccountService) Proxy.newProxyInstance(…..);这个对象就是accountService的代理对象<br>然后 <strong>invoke(….)</strong> 方法中，首先定义一个rtValue对象，这个是用来接收方法的返回值的，然后执行之前写的事务6步骤，在第2步执行method.invoke(accountService,args)方法，accountService参数是被代理的对象，args则是该方法的参数数组，执行完方法后返回值由rtValue来接收，然后第4步返回返回值，这里我们用Object类型来定义rtValue，所以在外面的return还要强转一下</p><p><font color="red">补充：</font><br>    因为增强方法实在匿名内部类中，又因为我们对象是用set方法注入的，所以我们要在accountService和transactionManager两个对象的set方法加上final关键字</p><h4 id="2、applicationContext-xml文件"><a href="#2、applicationContext-xml文件" class="headerlink" title="2、applicationContext.xml文件"></a>2、applicationContext.xml文件</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!--    1.配置代理的service对象，使用的是普通工厂的方法获取bean对象--&gt;        &lt;bean id=&quot;proxyAccountService&quot; factory-bean=&quot;beanFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;&lt;!--    2.配置factory对象--&gt;        &lt;bean id=&quot;beanFactory&quot; class=&quot;com.cbw.factory.BeanFactory&quot;&gt;            &lt;!--        注入service对象--&gt;                &lt;property name=&quot;accountService&quot; ref=&quot;accountService&quot;&gt;&lt;/property&gt;            &lt;!--        注入事务管理器对象，这个在第8步--&gt;                &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;&gt;&lt;/property&gt;        &lt;/bean&gt;&lt;!--    3.配置service对象--&gt;        &lt;bean id=&quot;accountService&quot; class=&quot;com.cbw.service.impl.AccountServiceImpl_new&quot;&gt;            &lt;!--        注入accountDao--&gt;                &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;            &lt;!--注入事务管理器对象--&gt;                &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;&gt;&lt;/property&gt;--&gt;        &lt;/bean&gt;&lt;!--    4.配置Dao对象--&gt;        &lt;bean id=&quot;accountDao&quot; class=&quot;com.cbw.dao.impl.AccountDaoImpl&quot;&gt;            &lt;!--        注入runner--&gt;                &lt;property name=&quot;runner&quot; ref=&quot;runner&quot;&gt;&lt;/property&gt;            &lt;!--注入ConnectionUtils--&gt;                &lt;property name=&quot;connectionUtils&quot; ref=&quot;connectionUtils&quot;&gt;&lt;/property&gt;        &lt;/bean&gt;&lt;!--    5.配置runner对象--&gt;        &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;&lt;!--    6.配置数据源--&gt;        &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;            &lt;!--        注入连接数据库的必备信息--&gt;                &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;                &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/myspringspace?useUnicode=true&amp;amp;characterEncoding=utf8&quot;&gt;&lt;/property&gt;                &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;                &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;        &lt;/bean&gt;&lt;!--    7.配置ConncetionUtils工具类--&gt;        &lt;bean id=&quot;connectionUtils&quot; class=&quot;com.cbw.utils.ConnectionUtils&quot;&gt;            &lt;!--        注入连接池--&gt;                &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;        &lt;/bean&gt;&lt;!--    8.创建事务管理器对象--&gt;        &lt;bean id=&quot;transactionManager&quot; class=&quot;com.cbw.utils.TransactionManager&quot;&gt;            &lt;!--        注入connectionUtils对象--&gt;                &lt;property name=&quot;connectionUtils&quot; ref=&quot;connectionUtils&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>用了c3p0连接池，还有apache的dbUtils工具包，实现的内容是一样的，用原生jdbc也是一样的效果，除此之外，没什么要补充的</p><p><font color="red">补充：</font><br>    第1步中获取的bean是accountService的代理对象所以也是IAccountService接口的实现类，再加上第3步中，我们又配置了一个具有相同接口的bean对象，所以我们在使用@Autowried自动注入的时候，要加上@Qualifier(“id”)指定注入的bean类型，不然会出错</p><h4 id="3、TestAccount测试类"><a href="#3、TestAccount测试类" class="headerlink" title="3、TestAccount测试类"></a>3、TestAccount测试类</h4><p>Junit整合spring在上一个笔记</p><pre><code>import com.cbw.domain.Account;import com.cbw.service.IAccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.List;/** * 使用junit单元测试测试我们的配置 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)public class accountTest {    @Autowired    @Qualifier(&quot;proxyAccountService&quot;)    private IAccountService accountService;    /**     * 测试转账方法     */    @Test    public void testTransfer(){        System.out.println(&quot;转账前&quot;);        testFindAll();        accountService.transfer(&quot;aaa&quot;,&quot;bbb&quot;,200f);        System.out.println(&quot;转账后&quot;);        testFindAll();    }    /**     * 测试查找全部方法     */    @Test    public void testFindAll(){        List&lt;Account&gt; accountList = accountService.findAllAccount();        System.out.println(accountList);    }}</code></pre><p>测试aaa给bbb转账200块，测试结果<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200331121018061.png" alt><br>转账成功，忽略中间的日志<br>我们再来测试一下，操作如果出问题，事务功能能否实现，在accountServiceImpl_new文件的transfer方法中加入 <strong>int i=1/0</strong>;<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200331121446847.png" alt><br>记住，aaa的钱是800，bbb是1200，如果转账出错，不会变的，测试结果<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200331121627473.png" alt><br>钱并没有变动，奇怪的是没有报错1/by zero</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring中的事务控制</title>
      <link href="/2020/04/10/spring%E5%AD%A6%E4%B9%A0(%E4%B8%83)/"/>
      <url>/2020/04/10/spring%E5%AD%A6%E4%B9%A0(%E4%B8%83)/</url>
      
        <content type="html"><![CDATA[<h1 id="spring中的事务控制"><a href="#spring中的事务控制" class="headerlink" title="spring中的事务控制"></a><font size="36">spring中的事务控制</font></h1><blockquote><p>环境：<br>Idea：2019.3.1<br>系统：windows10 家庭版<br>Jdk: 8<br>spring：5.0.3 release<br><a href="https://spring.io/projects/spring-framework" target="_blank" rel="noopener">spring文档</a><br><a href="https://github.com/iwishing/springStudyDemo" target="_blank" rel="noopener">项目代码</a></p></blockquote><h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一.概述"></a>一.概述</h3><pre><code>1.JavaEE体系进行分层开发，事务处理位于业务层，Spring提供了分层设计业务层的事务处理解决方案2.spring框架为我们提供了一组事务控制的接口，这组接口是在spring-tx-5.0.2.RELEASE.jar中3.spring的事务控制都是基于AOP的，它既可以使用编程的方式实现，也可以使用配置的方式实现</code></pre><h3 id="二-spring中事务控制的API介绍"><a href="#二-spring中事务控制的API介绍" class="headerlink" title="二.spring中事务控制的API介绍"></a>二.spring中事务控制的API介绍</h3><p><strong>PlatformTransactionManager</strong></p><p>此接口是spring的事务管理器，它里面提供了我们常用的操作事务的方法，包含3个具体的操作</p><pre><code>1.获取事务状态信息    TransactionStatus getTransaction(TransactionDefinition definition)2.提交事务    void commit(TransactionStatus status)3.回滚事务    void rollback(TransactionStatus status)</code></pre><p>我们在开发中都是使用它的实现类</p><pre><code>1.org.springframework.jdbc.datasource.DataSourceTransactionManager    使用Spring JDBC或iBatis进行持久化数据时使用2.org.springframework.orm.hibernate5.HibernateTransactionManager    使用Hibernate版本进行持久化数据时使用</code></pre><p><strong>TransactionDefinition</strong><br>它是事务的定义信息对象，包含的方法如下</p><p><font size="2" color="black">String getName()</font></p><pre><code>获取事务对象名称</code></pre><p><font size="2" color="black">int getIsolationLevel()</font></p><pre><code>获取事务隔离级别事务的隔离级别反映事务提交并发访问时的处理态度    -ISOLATION_DEFAULT        默认级别，归属于下列某一种    -ISOLATION_READ_UNCOMMITTED        可以读取未提交数据    -ISOLATION_READ_COMMITEED        只能读取已提交数据，解决脏读问题(Oracle默认级别)    -ISOLATION_REPEATABLE_READ        是否读取其他事务提交修改后的数据，解决不可重复读问题(MySQL默认级别)    -ISOLATION_SERIALIZABLE        是否读取其他事务提交添加后的数据，解决幻影读问题</code></pre><p><font size="2" color="black">int getPropagationBehavior()</font></p><pre><code>获取事务传播行为事务的传播行为    REQUIRED：        如果当前没有事务，就新建一个事务，如果已经存在于一个事务中，则加入到这个事务中。一般的选择(默认值)    SUPPORTS：        支持当前事务，如果当前没有事务，就以非事务方式执行(没有事务)    MANDATORY：        使用当前的事务，如果当前没有事务，就抛出异常    REQUERS_NEW：        新建事务，如果当前在事务中，把当前事务挂起    NOT_SUPPORTED：        以非事务方式执行操作，如果当前存在事务，就把当前事务挂起    NEVER：        以非事务方式运行，如果当前存在事务，抛出异常    NESTED：        如果当前存在事务，则在嵌套事务内执行，如果当前没有事务，则执行REQUIRED类似的操作</code></pre><p><font size="2" color="black">int getTimeout()</font></p><pre><code>获取事务超时时间默认值是-1，就是没有超时限制，如果有，以秒为单位进行设置</code></pre><p><font size="2" color="black">boolean isReadOnly()</font></p><pre><code>获取事务是否只读读写型事务：增加、删除、修改开启事务只读型事务：查询时开启事务，建议查询时设置为只读</code></pre><p><strong>TransactionStatus</strong><br>此接口提供的是事务具体的运行状态，包含了6个具体的操作</p><p><font size="2" color="black">void flush()</font></p><pre><code>刷新事务</code></pre><p><font size="2" color="black">boolean hasSavepoint()</font></p><pre><code>获取是否存在存储点</code></pre><p><font size="2" color="black">boolean isCompleted()</font></p><pre><code>获取事务是否完成</code></pre><p><font size="2" color="black">boolean isNewTransaction()</font></p><pre><code>获取事务是否为新的事务</code></pre><p><font size="2" color="black">boolean isRollbackOnly()</font></p><pre><code>获取事务是否回滚</code></pre><p><font size="2" color="black">void setRollbackOnly()</font></p><pre><code>设置事务回滚</code></pre><h3 id="三-spring中基于xml的声明式事务控制"><a href="#三-spring中基于xml的声明式事务控制" class="headerlink" title="三.spring中基于xml的声明式事务控制"></a>三.spring中基于xml的声明式事务控制</h3><p>沿用上篇文章中的使用spring的JdbcDaoSupport的工程文件，然后做以下修改</p><h5 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h5><p>别忘了导入spring-jdbc和spring-tx的坐标，其他所需要的按照之前项目导</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/tx        https://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/aop        https://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/context        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt;</code></pre><h5 id="配置事务管理器"><a href="#配置事务管理器" class="headerlink" title="配置事务管理器"></a>配置事务管理器</h5><pre><code>&lt;!--    配置事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h5 id="配置事务的通知"><a href="#配置事务的通知" class="headerlink" title="配置事务的通知"></a>配置事务的通知</h5><p>配置事务的通知<br><code>&lt;tx:advice&gt;&lt;/tx:advice&gt;</code></p><pre><code>属性：    id：给事务通知起一个唯一标识    transaction-manager：给事务通知提供一个事务管理器引用</code></pre><p>配置事务的属性<br><code>&lt;tx:attributes&gt;&lt;/tx:attributes&gt;</code><br>在这个标签里面用<code>&lt;tx:method/&gt;</code>标签指定切入点和属性</p><pre><code>属性：    name=&quot;&quot;:用于指定切入点名称    isolation=&quot;&quot;：用于指定事务的隔离级别，默认值是DEFAULT，表示使用数据库的隔离级别    propagation=&quot;&quot;用于指定事务的传播行为，默认值是REQUIRED，表示一定会有事务，增删改的选择，查询方法可以选择SUPPORTS    read-only=&quot;&quot;用于指定事务是否只读，只有查询方法才能设置为true，默认值是false，表示读写    timeout=&quot;&quot;用于指定事务的超时时间，默认值是-1，表示永不超时，如果指定了数值，以秒为单位    no-rollback-for=&quot;&quot;用于指定一个异常，表示当该异常发生时事务不回滚，产生其他异常时都回滚，没有默认值，表示任何异常都回滚    rollback-for=&quot;&quot;用于指定一个异常，表示当该异常发生时事务回滚，产生其他异常时事务不回滚，没有默认值，表示任何异常都回滚</code></pre><p>name属性可以使用<strong>通配符</strong>来表示多个连接点，所以我们一般地将查询方法都用find开头，这样在设置<code>&lt;tx:method/&gt;</code>属性时，可以直接指定name = “find*”，因为事务的原因，我们一般都按照下面这种写法，为什么这样设置，可以查看最上面对这些属性的值的说明</p><pre><code>&lt;!-- 配置事务的通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;&lt;!--    配置事务的属性--&gt;    &lt;tx:attributes&gt;        //增删改方法，命名按自己的来，propagation=&quot;REQUIRED&quot;,read-only设置为读写        &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&gt;        //所有查询方法都用find打头，这里用find*指定所有查询方法，然后设置propagation=&quot;SUPPORTS&quot;,read-only设置为只读        &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;&gt;&lt;/tx:method&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;</code></pre><h5 id="配置aop中的通用切入点表达式并和事务通知建立关系"><a href="#配置aop中的通用切入点表达式并和事务通知建立关系" class="headerlink" title="配置aop中的通用切入点表达式并和事务通知建立关系"></a>配置aop中的通用切入点表达式并和事务通知建立关系</h5><pre><code>&lt;!--    配置aop中的通用切入点表达式--&gt;    &lt;aop:config&gt;        &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.cbw.service.impl.*.*(..))&quot;/&gt;        &lt;!--    建立事务通知和切入点表达式的关系--&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:advisor&gt;    &lt;/aop:config&gt;</code></pre><p>完整的配置文件如下</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/tx        https://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/aop        https://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/context        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.cbw&quot;&gt;&lt;/context:component-scan&gt;&lt;!--    配置账户的持久层--&gt;    &lt;bean id=&quot;accountDao&quot; class=&quot;com.cbw.dao.impl.AccountDaoImpl&quot;&gt;            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/myspringspace&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;!--    1.配置事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--    2.配置事务的通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;&lt;!--5.配置事务的属性--&gt;    &lt;tx:attributes&gt;        &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&gt;        &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;&gt;&lt;/tx:method&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--    3.配置aop中的通用切入点表达式--&gt;    &lt;aop:config&gt;        &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.cbw.service.impl.*.*(..))&quot;/&gt;        &lt;!--    4.建立事务通知和切入点表达式的关系--&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:advisor&gt;    &lt;/aop:config&gt;&lt;/beans&gt;</code></pre><p>测试<br>我们运行带<font color="red">int i=1/0</font>错误的转账方法<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200406104228134/20200410103718331.png" alt><br>可以看到转账钱这么多钱，然后报错了，我们再去表中看下，是否转账人转了帐，收账人没收到<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200406104228134/20200410103812083.png" alt><br>可以看到，既没有转账也没有收账，说明事务配置成功了</p><h3 id="四-spring中基于注解的事务控制"><a href="#四-spring中基于注解的事务控制" class="headerlink" title="四.spring中基于注解的事务控制"></a>四.spring中基于注解的事务控制</h3><p>使用纯注解的方式实现</p><h5 id="创建配置类"><a href="#创建配置类" class="headerlink" title="创建配置类"></a>创建配置类</h5><p>1.springConfiguration</p><blockquote><p>主配置文件</p></blockquote><pre><code>import org.springframework.context.annotation.*;import org.springframework.transaction.annotation.EnableTransactionManagement;/** * spring的配置类，相当于applicationContext.xml *///表示这是一个配置类@Configuration//设置要扫描的包@ComponentScan(&quot;com.cbw&quot;)//导入另外两个配置类@Import({JdbcConfig.class,TransactionConfig.class})//导入外部的properties文件，里面写了数据库连接所需参数@PropertySource(&quot;jdbcConfig.properties&quot;)//开启事务支持@EnableTransactionManagementpublic class SpringConfiguration {}</code></pre><p>2.JdbcConfig</p><blockquote><p>和数据库相关的配置类</p></blockquote><pre><code>import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;/** * 和连接数据库相关的类 */public class JdbcConfig {    @Value(&quot;${jdbc.driver}&quot;)    private String classDriver;    @Value(&quot;${jdbc.url}&quot;)    private String url;    @Value(&quot;${jdbc.username}&quot;)    private String username;    @Value(&quot;${jdbc.password}&quot;)    private String password;    /**     *     * 创建JdbcTemplate对象     * @param dataSource     * @return     */    @Bean(name = &quot;jdbcTemplate&quot;)    public JdbcTemplate createJdbcTemplate(DataSource dataSource){        return new JdbcTemplate(dataSource);    }    @Bean(name = &quot;dataSource&quot;)    public DataSource createDataSource(){        DriverManagerDataSource driverManagerDataSource = new DriverManagerDataSource();        driverManagerDataSource.setDriverClassName(classDriver);        driverManagerDataSource.setUrl(url);        driverManagerDataSource.setUsername(username);        driverManagerDataSource.setPassword(password);        return driverManagerDataSource;    }}</code></pre><p> 3.TransactionConfig</p><blockquote><p>和事务相关的配置类</p></blockquote><pre><code>import org.springframework.context.annotation.Bean;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.PlatformTransactionManager;import javax.sql.DataSource;/** * 和事务相关的配置类 */public class TransactionConfig {    /**     * 用于创建事务管理器对象的     * @param dataSource     * @return     */    @Bean(&quot;TransactionManager&quot;)    public PlatformTransactionManager createTransactionManager(DataSource dataSource){        return new DataSourceTransactionManager(dataSource);    }}</code></pre><h5 id="jdbcConfig-properties文件"><a href="#jdbcConfig-properties文件" class="headerlink" title="jdbcConfig.properties文件"></a>jdbcConfig.properties文件</h5><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/myspringspacejdbc.username=rootjdbc.password=123456</code></pre><h5 id="业务层开启事务"><a href="#业务层开启事务" class="headerlink" title="业务层开启事务"></a>业务层开启事务</h5><p> 用<code>@Transactional</code>注解在service层中的service实现类，开启事务</p><pre><code>import com.cbw.dao.IAccountDao;import com.cbw.domain.Account;import com.cbw.service.IAccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Service(&quot;accountService&quot;)@Transactionalpublic class AccountServiceImpl implements IAccountService {    @Autowired    private IAccountDao accountDao;    public Account findAccountByID(Integer accountId) {        return accountDao.findAccountById(accountId);    }    public void transfer(String sourceName, String targetName, Float money) {        //1.查询出转账人        Account source = accountDao.findAccountByName(sourceName);        //2.查询出收账人        Account target = accountDao.findAccountByName(targetName);        //3.转账人减钱        source.setMoney(source.getMoney() - money);        //4.收账人加钱        target.setMoney(target.getMoney() + money);        //5.更新两个账户        accountDao.updateAccount(source);        accountDao.updateAccount(target);    }}</code></pre><p>当然这里也可以给方法设置事务属性，还是<code>@Transactional</code>标签</p><pre><code>    @Transactional(propagation = Propagation.REQUIRED,readOnly = true)    public Account findAccountByID(Integer accountId) {        return accountDao.findAccountById(accountId);    }</code></pre><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>之前的<code>@ContextConfiguration</code>标签里面的location参数改成classes，指明配置类</p><pre><code>import com.cbw.config.SpringConfiguration;import com.cbw.domain.Account;import com.cbw.service.IAccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfiguration.class)public class TestTx {    @Autowired    private IAccountService as;    @Test    public void testTransfer(){        //转账前        System.out.println(&quot;转账前&quot;);        Account source = as.findAccountByID(1);        Account target = as.findAccountByID(2);        System.out.println(&quot;转账人：&quot; + source);        System.out.println(&quot;收账人：&quot; + target);        //转账        as.transfer(source.getName(),target.getName(),200f);        //转账后        System.out.println(&quot;转账后&quot;);        source = as.findAccountByID(1);        target = as.findAccountByID(2);        System.out.println(&quot;转账人：&quot; + source);        System.out.println(&quot;收账人：&quot; + target);    }}</code></pre><p>老样子，在转账的方法中，加入<font color="red">int i=1/0;</font><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200406104228134/20200410012558271.png" alt><br>查看表<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200406104228134/20200410012617193.png" alt><br>一样没变</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring中的JdbcTemplate</title>
      <link href="/2020/04/10/spring%E5%AD%A6%E4%B9%A0(%E5%85%AD)/"/>
      <url>/2020/04/10/spring%E5%AD%A6%E4%B9%A0(%E5%85%AD)/</url>
      
        <content type="html"><![CDATA[<h1 id="spring中的JdbcTemplate"><a href="#spring中的JdbcTemplate" class="headerlink" title="spring中的JdbcTemplate"></a><font size="36">spring中的JdbcTemplate</font></h1><blockquote><p>环境：<br>Idea：2019.3.1<br>系统：windows10 家庭版<br>Jdk: 8<br>spring：5.0.3 release<br><a href="https://spring.io/projects/spring-framework" target="_blank" rel="noopener">spring文档</a><br><a href="https://github.com/iwishing/springStudyDemo" target="_blank" rel="noopener">项目代码</a></p></blockquote><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h5><pre><code>它是spring框架中提供的一个对象，是对原始Jdbc AOP对象的简单封装，spring框架为我们提供了很多的操作模板类。操作关系型数据的：    JDBCTemplate    HibernateTemplate操作Nosql数据库的    RedisTemplate操作消息队列的：    JMSTemplate</code></pre><p>JdbcTemplate在 <code>spring-jdbc-5.0.2.RELEASE.jar</code> 中，导入包的时候，除了这个jar包，还得导入一个和事务相关的包<br><code>spring-tx-5.0.2.RELEASE.jar</code></p><h5 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h5><p>配置JdbcTemplate及数据源</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!--    配置jdbctemplate--&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/myspringspace&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>使用JdbcTemplate插入账户数据</p><pre><code>public class JdbcTemplateDemo2 {    public static void main(String[] args) {        //1.获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //2.获取JdbcTemplate对象        JdbcTemplate jt = (JdbcTemplate) ac.getBean(&quot;jdbcTemplate&quot;,JdbcTemplate.class);        //3.执行语句        jt.execute(&quot;insert into account(name,money)values(&#39;xxx&#39;,10000)&quot;);    }}</code></pre><h5 id="3-实现curd操作"><a href="#3-实现curd操作" class="headerlink" title="3.实现curd操作"></a>3.实现curd操作</h5><font size="4" color="black">保存</font><br><code>jt.update(&quot;insert into account(name,money)values(?,?)&quot;,&quot;zzz&quot;,1000f);</code><br><font size="4" color="black">更新</font><br><code>jt.update(&quot;update account set name=?,money=? where id=?&quot;,&quot;llll&quot;,20000f,8);</code><br><font size="4" color="black">删除</font><br><code>jt.update(&quot;delete from account where id=?&quot;,9);</code><br><font size="4" color="black">查询</font><br><strong>查询所有</strong><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200406104228134/20200406103704460.png" alt><br>这是所有的query方法，但是并不是都能用到，我们通过2点来过滤<br><em> 我们提供什么：sql语句，语句的参数</em> 我们需要什么：返回一个List集合<br><br>根据这两点我们能定位到，只剩两个方法我们更适合去使用<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200406104228134/20200406104011033.png" alt><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200406104228134/20200406104052809.png" alt><br>这两个方法是针对不同的JDK版本使用的，第一个所有版本都能使用，第二个是JDK1.5之后才能使用，因为参数中有了可变参数<br>我们是JDK1.8所以能够使用第二种，这里我们使用第二种来查询<br><code>accountList = jt.query(&quot;select * from account where money=?&quot;, 第二个参数 ,1000f);</code><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200406104228134/20200406112404435.png" alt><br>定位到RowMapper后发现，它是一个接口，所以我们要使用它的实现类来作为参数传入进方法<br><code>/** * 定义account封装策略 */class AccountRowMapper implements RowMapper {    /**     * 把结果集中的数据封装到Account中，并由spring把每个Account加入到List集合中     *     * @param resultSet     * @param i     * @return     * @throws SQLException     */    public Object mapRow(ResultSet resultSet, int i) throws SQLException {    //这里可以将Account的属性和表中的字段对应起来        Account account = new Account();        account.setId(resultSet.getInt(&quot;id&quot;));        account.setName(resultSet.getString(&quot;name&quot;));        account.setMoney(resultSet.getFloat(&quot;money&quot;));        return account;    }}</code><br>完整的查询语句是这样的<br><code>List&lt;Account&gt; accountList = jt.query(&quot;select * from account where money&gt;?&quot;,new AccountRowMapper(),1000f);</code><br>当然我们也可以使用spring为我们提供的RowMapper接口实现类<code>BeanPropertyRowMapper&lt;T&gt;</code><br><code>//传入Account字节码List&lt;Account&gt; accountList = jt.query(&quot;select * from account where money&gt;?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),1000f);</code><br>类比一下dbutils中的QueryRunner中的query方法<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200406104228134/20200406113724015.png" alt><br><em> QueryRunner.query：它的返回值类型是一个泛型，它的返回值类型是由ResultSethandler<t>中的返回值类型来觉得的</t></em> JdbcTemplate.query：它的返回值类型是由不同的query方法来实现返回的，根据最开始截的那张query方法图能发现，有很多query方法，有参数不同的，有返回值不同的<br><br><strong>查询一个</strong><br>还是可以使用查询所有的方法<br><code>//传入Account字节码List&lt;Account&gt; accountList = jt.query(&quot;select * from account where id=?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),1);//取出查询结果System.out.println(accountList.isEmpty() ? &quot;没有内容&quot; : accountList.get(0));</code><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200406104228134/20200406115300756.png" alt><br>可以看到取出来id为1的账户<br>因为这一个方法可以满足查询任何情况，所以实际开发中也是使用这个方法<br><strong>查询返回一行一列(使用聚合函数，但是不加group by字句)</strong><br><code>//因为要返回一行一列，一行一列可以认为是一个数据，就像count(*)函数的结果，所以不能使用query方法，而是要使用queryForObject方法//第二个参数填返回值类型的字节码，你传的什么类型的字节码，那么这个方法的返回值就是那个数据类型，我们使用的是long，所以我们用long来接受，int也可以，但是如果实际数据大于int的数据范围就会报错，所以实际上我们直接使用更大的long来接受long count = jt.queryForObject(&quot;select count(*) from account where money&gt;?&quot;,long.class,1000f);System.out.println(count);</code><br>##### 4.Jdbc的使用以及Dao的两种配置方式 #####<br>刚刚是在main方法执行的语句，但是实际开发中，main方法一般是留给测试人员使用，我们应该将语句的执行放在dao层，我们新建dao层，创建<font color="red">IAccountServce</font>接口，创建<font color="red">AccountServceImpl</font>类，如下<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200406104228134/20200408045836820.png" alt><br>AccountServiceImpl代码如下<br><code>import com.cbw.dao.IAccountDao;import com.cbw.domain.Account;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import java.util.List;/** * 账户的持久层实现类 */public class AccountDaoImpl3 implements IAccountDao {    private JdbcTemplate jdbcTemplate;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {        this.jdbcTemplate = jdbcTemplate;    }    public Account findAccountById(Integer accountId) {        List&lt;Account&gt; accountList = jdbcTemplate.query(&quot;select * from account where id=?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountId);        return accountList.isEmpty()?null:accountList.get(0);    }    public Account findAccountByName(String accountName) {        List&lt;Account&gt; accountList = jdbcTemplate.query(&quot;select * from account where name =?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountName);        return accountList.isEmpty()?null:accountList.get(0);    }    public void updateAccount(Account account) {        jdbcTemplate.update(&quot;update account set name=?,money=? where id=?&quot;,account.getName(),account.getMoney(),account.getId());    }}</code><br>试想一下，如果dao层实现类比较多，实际开发肯定不止这一个啊，那么我们每一个daoimp里面都有这段重复代码<br><code>private JdbcTemplate jdbcTemplate;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {        this.jdbcTemplate = jdbcTemplate;    }</code><br>新建一个JdbcDaoSupport类<br><code>import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;/** * 此类用于抽取dao中的重复代码 */public class JdbcDaoSupport {    private JdbcTemplate jdbcTemplate;    public JdbcTemplate getJdbcTemplate() {        return jdbcTemplate;    }    public void setDataSource(DataSource dataSource) {        if(jdbcTemplate == null){            jdbcTemplate = createJdbcTemplate(dataSource);        }    }    private JdbcTemplate createJdbcTemplate(DataSource dataSource){        return new JdbcTemplate(dataSource);    }}</code><br>然后让accountDaoImpl类继承这个类，就只需要使用super关键子调用jdbcTemplate类了<br><code>import com.cbw.dao.IAccountDao;import com.cbw.domain.Account;import org.springframework.jdbc.core.BeanPropertyRowMapper;import java.util.List;/** * 账户的持久层实现类 */public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao {    public Account findAccountById(Integer accountId) {        List&lt;Account&gt; accountList = super.getJdbcTemplate().query(&quot;select * from account where id=?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountId);        return accountList.isEmpty()?null:accountList.get(0);    }    public Account findAccountByName(String accountName) {        List&lt;Account&gt; accountList = super.getJdbcTemplate().query(&quot;select * from account where name =?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountName);        return accountList.isEmpty()?null:accountList.get(0);    }    public void updateAccount(Account account) {        super.getJdbcTemplate().update(&quot;update account set name=?,money=? where id=?&quot;,account.getName(),account.getMoney(),account.getId());    }}</code><br>别忘了在xml文件中，配置accountDao，并在里面注入dataSource<br><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!--    配置账户的持久层--&gt;    &lt;bean id=&quot;accountDao&quot; class=&quot;com.cbw.dao.impl.AccountDaoImpl&quot;&gt;            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/myspringspace&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code><br>执行测试<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200406104228134/20200408053851108.png" alt><br>当然，spring中也给我们实现了这种方式，我们可以直接继承spring中的JdbcDaoSupport类<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200406104228134/20200408053026231.png" alt><br>我们就不需要自己写support类，但是，这样写的话，我们就不能自己用注解配置jdbcTemplate了，因为那个是spring提供的jar包里面的，所以，<font color="red">当我们使用继承spring中的JdbcDaoSupport类时，我们是使用xml配置dao的，当我们不使用这种方式，我们就可以使用注解方式来配置dao了，怎么选择看我们自己</font>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>依赖注入，spring基于注解的IoC，spring整合junit</title>
      <link href="/2020/04/10/spring%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
      <url>/2020/04/10/spring%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h1 id="依赖注入，spring基于注解的IoC，spring整合junit"><a href="#依赖注入，spring基于注解的IoC，spring整合junit" class="headerlink" title="依赖注入，spring基于注解的IoC，spring整合junit"></a><font size="36">依赖注入，spring基于注解的IoC，spring整合junit</font></h1><blockquote><p>环境：<br>Idea：2019.3.1<br>系统：windows10 家庭版<br>Jdk: 8<br>spring：5.0.3 release<br><a href="https://spring.io/projects/spring-framework" target="_blank" rel="noopener">spring文档</a><br><a href="https://github.com/iwishing/springStudyDemo" target="_blank" rel="noopener">项目代码</a></p></blockquote><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>spring中的依赖注入,依赖关系的管理，以后都交给spring来维护，在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明，依赖关系的维护，就称为依赖注入，但如果是经常变化的数据，并不适用于注入的方式</p><h4 id="一-applicationContext-xml文件头"><a href="#一-applicationContext-xml文件头" class="headerlink" title="一.applicationContext.xml文件头"></a>一.applicationContext.xml文件头</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;        &lt;bean&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><h4 id="二-数据类型"><a href="#二-数据类型" class="headerlink" title="二.数据类型"></a>二.数据类型</h4><h6 id="1-基本类型和String"><a href="#1-基本类型和String" class="headerlink" title="1.基本类型和String"></a>1.基本类型和String</h6><h6 id="2-其他bean类型（在配置文件中或者注解配置过的bean）"><a href="#2-其他bean类型（在配置文件中或者注解配置过的bean）" class="headerlink" title="2.其他bean类型（在配置文件中或者注解配置过的bean）"></a>2.其他bean类型（在配置文件中或者注解配置过的bean）</h6><h6 id="3-复杂类型-集合类型"><a href="#3-复杂类型-集合类型" class="headerlink" title="3.复杂类型/集合类型"></a>3.复杂类型/集合类型</h6><h4 id="三-注入方式"><a href="#三-注入方式" class="headerlink" title="三.注入方式"></a>三.注入方式</h4><h6 id="1-构造函数注入"><a href="#1-构造函数注入" class="headerlink" title="1.构造函数注入"></a>1.构造函数注入</h6><p>标签：<code>&lt;constructor-arg/&gt;</code></p><pre><code>位置：&lt;bean&gt;&lt;/bean&gt;内部属性：    type：    用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型    index：   用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始的    name：    用于指定给构造函数中指定名称的参数赋值（最常用）    value：   用于提供基本类型和String类型的数据    ref：     用于指定其他的bean类型数据，它指的就是在spring的IoC核心容器中出现的bean对象优势：    在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功，即当我们需要某个类的实例对象一定拥有值的时候，就可以用这种方式注入弊端：    改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供</code></pre><p>例子：</p><pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.cbw.service.impl.AccountServiceImpl&quot;&gt;    &lt;constructor-arg name=&quot;name&quot; value=&quot;test&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;    //birthday是date对象，spring无法用字符串转换，所以要创建一个date类型的bean对象， 再用ref属性引用    &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;birthday&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;//创建一个date类型bean供birthday使用&lt;bean id=&quot;birthday&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;   </code></pre><h6 id="2-set方法注入（常用）"><a href="#2-set方法注入（常用）" class="headerlink" title="2.set方法注入（常用）"></a>2.set方法注入（常用）</h6><p>标签：<code>&lt;property/&gt;</code></p><pre><code>位置：&lt;bean&gt;&lt;/bean&gt;内部属性：    name：     用于指定注入时所调用的set方法名称    value：    用于提供基本类型和String类型的数据    ref：      用于指定其他的bean类型数据，它指的就是在spring的IoC核心容器中出现的bean对象优势：    创建对象时没有明确的限制，可以直接使用默认构造函数，即使用无参构造函数都行弊端：    如果有某个成员必须有值，则获取对象是有可能set方法没有执行，即可能调用的默认构造函数创建对象，然后用完了都没有调用set方法，也就没有值</code></pre><p>例子：</p><pre><code>&lt;bean id=&quot;accountServic&quot; class=&quot;com.cbw.service.impl.AccountServiceImpl2&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;cbw&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;birthday&quot; ref=&quot;birthday&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;birthday&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;</code></pre><h6 id="3-注解注入"><a href="#3-注解注入" class="headerlink" title="3.注解注入"></a>3.注解注入</h6><p><font color="red">见下文</font></p><h4 id="四-复杂类型的注入-集合类型的注入（能够使用构造方法和set方法注入，这里我们使用set方法）"><a href="#四-复杂类型的注入-集合类型的注入（能够使用构造方法和set方法注入，这里我们使用set方法）" class="headerlink" title="四.复杂类型的注入/集合类型的注入（能够使用构造方法和set方法注入，这里我们使用set方法）"></a>四.复杂类型的注入/集合类型的注入（能够使用构造方法和set方法注入，这里我们使用set方法）</h4><h6 id="1-用于给List结构集合注入的标签："><a href="#1-用于给List结构集合注入的标签：" class="headerlink" title="1.用于给List结构集合注入的标签："></a>1.用于给List结构集合注入的标签：</h6><pre><code>   &lt;list&gt;&lt;/list&gt;    &lt;array&gt;&lt;/array&gt;   &lt;set&gt;&lt;/set&gt;</code></pre><h6 id="2-用于给Map结构集合注入的标签："><a href="#2-用于给Map结构集合注入的标签：" class="headerlink" title="2.用于给Map结构集合注入的标签："></a>2.用于给Map结构集合注入的标签：</h6><pre><code>   &lt;map&gt;&lt;/map&gt;    &lt;props&gt;&lt;/props&gt;</code></pre><h6 id="注：结构相同，标签可以互换，也就是能共用标签-当然只能使用一种，这些标签的位置都是在-lt-bean-gt-lt-bean-gt-标签里面"><a href="#注：结构相同，标签可以互换，也就是能共用标签-当然只能使用一种，这些标签的位置都是在-lt-bean-gt-lt-bean-gt-标签里面" class="headerlink" title="注：结构相同，标签可以互换，也就是能共用标签,当然只能使用一种，这些标签的位置都是在&lt;bean&gt;&lt;/bean&gt;标签里面"></a>注：结构相同，标签可以互换，也就是能共用标签,当然只能使用一种，这些标签的位置都是在<code>&lt;bean&gt;&lt;/bean&gt;</code>标签里面</h6><h6 id="字符串数组-lt-array-gt-lt-array-gt"><a href="#字符串数组-lt-array-gt-lt-array-gt" class="headerlink" title="字符串数组 &lt;array&gt;&lt;/array&gt;"></a>字符串数组 <code>&lt;array&gt;&lt;/array&gt;</code></h6><pre><code>                    &lt;property name=&quot;myStrs&quot;&gt;                         &lt;array&gt;                             &lt;value&gt;sss&lt;/value&gt;                             &lt;value&gt;fff&lt;/value&gt;                             &lt;value&gt;ddd&lt;/value&gt;                         &lt;/array&gt;                    &lt;/property&gt;</code></pre><h6 id="List-lt-list-gt-lt-list-gt"><a href="#List-lt-list-gt-lt-list-gt" class="headerlink" title="List&lt;list&gt;&lt;/list&gt;"></a>List<code>&lt;list&gt;&lt;/list&gt;</code></h6><pre><code>                    &lt;property name=&quot;myList&quot;&gt;                        &lt;list&gt;                            &lt;value&gt;123&lt;/value&gt;                            &lt;value&gt;234&lt;/value&gt;                            &lt;value&gt;345&lt;/value&gt;                        &lt;/list&gt;                    &lt;/property&gt;</code></pre><h6 id="Map-lt-map-gt-lt-map-gt"><a href="#Map-lt-map-gt-lt-map-gt" class="headerlink" title="Map &lt;map&gt;&lt;/map&gt;"></a>Map <code>&lt;map&gt;&lt;/map&gt;</code></h6><pre><code>                    &lt;property name=&quot;myMap&quot;&gt;                        //想使用自定义bean，用key-ref=&quot;***&quot; value-ref=&quot;***&quot;属性连接外部bean                        &lt;map key-type=&quot;java.lang.String&quot; value-type=&quot;java.lang.String&quot;&gt;                            //用value属性传值                            &lt;entry key=&quot;墨菲特&quot; value=&quot;势不可挡&quot; &gt;&lt;/entry&gt;                            &lt;entry key=&quot;亚托克斯&quot; value=&quot;大灭&quot;&gt;&lt;/entry&gt;                            //用value标签传值                            &lt;entry key=&quot;亚索&quot;&gt;                                &lt;value&gt;狂风绝息斩&lt;/value&gt;                            &lt;/entry&gt;                        &lt;/map&gt;                    &lt;/property&gt;</code></pre><h6 id="Set-lt-set-gt-lt-set-gt"><a href="#Set-lt-set-gt-lt-set-gt" class="headerlink" title="Set&lt;set&gt;&lt;/set&gt;"></a>Set<code>&lt;set&gt;&lt;/set&gt;</code></h6><pre><code>                    &lt;property name=&quot;mySet&quot;&gt;                        &lt;set&gt;                            &lt;value&gt;set1&lt;/value&gt;                            &lt;value&gt;set2&lt;/value&gt;                            &lt;value&gt;set3&lt;/value&gt;                        &lt;/set&gt;                    &lt;/property&gt;</code></pre><h6 id="Properties-lt-props-gt-lt-props-gt"><a href="#Properties-lt-props-gt-lt-props-gt" class="headerlink" title="Properties &lt;props&gt;&lt;/props&gt;"></a>Properties <code>&lt;props&gt;&lt;/props&gt;</code></h6><pre><code>                    &lt;property name=&quot;myProperties&quot;&gt;                        &lt;props&gt;                            &lt;prop key=&quot;accountService1&quot;&gt;唉唉唉&lt;/prop&gt;                            &lt;prop key=&quot;accountService2&quot;&gt;哈哈哈&lt;/prop&gt;                            &lt;prop key=&quot;accountService3&quot;&gt;嘻嘻嘻&lt;/prop&gt;                        &lt;/props&gt;                    &lt;/property&gt;</code></pre><h6 id="用-key-ref-”“-value-ref-”“属性连接外部bean"><a href="#用-key-ref-”“-value-ref-”“属性连接外部bean" class="headerlink" title="用 key-ref=”“ value-ref=”“属性连接外部bean"></a>用 key-ref=”<strong><em>“ value-ref=”</em></strong>“属性连接外部bean</h6><pre><code>            &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;//自定义date对象            &lt;bean id=&quot;accountService&quot; class=&quot;com.cbw.service.impl.AccountServiceImpl4&quot;&gt;                &lt;property name=&quot;myMap&quot;&gt;                    &lt;map&gt;                        &lt;entry key-ref=&quot;now&quot; value-ref=&quot;now&quot;&gt;&lt;/entry&gt;                    &lt;/map&gt;                &lt;/property&gt;            &lt;/bean&gt;</code></pre><h2 id="基于注解的IoC"><a href="#基于注解的IoC" class="headerlink" title="基于注解的IoC"></a>基于注解的IoC</h2><h4 id="一-applicationContext-xml文件"><a href="#一-applicationContext-xml文件" class="headerlink" title="一.applicationContext.xml文件"></a>一.applicationContext.xml文件</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;       http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;&lt;!--告知spring在创建容器的时候要扫描的包，配置所需要的标签不是在beans的约束中，    而是一个名称为context名称空间和约束中--&gt;&lt;context:component-scan base-package=&quot;com.cbw&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt;</code></pre><h4 id="二-创建对象相关"><a href="#二-创建对象相关" class="headerlink" title="二.创建对象相关"></a>二.创建对象相关</h4><p>他们的作用就和在xml配置文件中编写一个<code>&lt;bean&gt;&lt;/bean&gt;</code>标签实现的功能是一样的</p><h6 id="1-Component"><a href="#1-Component" class="headerlink" title="1.@Component"></a>1.@Component</h6><pre><code>作用：    用于把当前类对象存入spring容器位置：    类属性：     value：用于指定bean的id，当我们不写时，默认值是当前类名，且首字母变小写</code></pre><h6 id="2-Controller-———一般用在表现层"><a href="#2-Controller-———一般用在表现层" class="headerlink" title="2.@Controller ———一般用在表现层"></a>2.@Controller ———一般用在表现层</h6><h6 id="3-Service-———–一般用在业务层"><a href="#3-Service-———–一般用在业务层" class="headerlink" title="3.@Service  ———–一般用在业务层"></a>3.@Service  ———–一般用在业务层</h6><h6 id="4-Repository-——–一般用在持久层"><a href="#4-Repository-——–一般用在持久层" class="headerlink" title="4.@Repository  ——–一般用在持久层"></a>4.@Repository  ——–一般用在持久层</h6><pre><code>      以上三个注解他们的作用和属性和Component是一模一样，他们三个是spring框架为我们提供明确的三层使用的注解，使我们的三层更加清晰</code></pre><p></p><h4 id="1">三.用于注入数据 <br>他们的作用就和在xml配置文件中的bean标签中写一个property标签的作用是一样的<p></p><h6 id="1-Autowired"><a href="#1-Autowired" class="headerlink" title="1.@Autowired"></a>1.@Autowired</h6><pre><code>作用：    自动按照类型注入，只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功位置：    方法，变量细节：    在使用注解注入时，set方法就不是必须的例子：                               @Repository(&quot;accountDaoImpl&quot;)                               public class AccountDaoImpl implements IAccountDao {                               @Autowired                               private IAccountDao iAccountDao;                               ```                               省略众多方法                               ```                               }注意：    IoC容器是一个Map类型，注解时的id是key，bean的类名是value，这里就是id=accountDaoImpl，value=AccountDaoImpl（implement IAccountDao也会记录下来）自动注入：                     1.根据数据类型寻找value是一样的bean                     2.如果IoC容器中，一个匹配的bean类型都没有，注入就会失败报错（如果是接口，那么他的实现类也能匹配）                     3.如果IoC容器中，有bean匹配的时候:                            1.有一个匹配的时候                                   直接注入                            2.有多个匹配的时候                                   根据变量类型，圈定出所有匹配的bean                                   根据变量名称，逐个比对圈定的bean的id值，如果有相同的，那么就匹配这个                                   如果几个都一样，或者一个都没有，就会报错</code></pre><h6 id="2-Qalifier"><a href="#2-Qalifier" class="headerlink" title="2.@Qalifier"></a>2.@Qalifier</h6><pre><code>作用：在按照类中注入的基础上再按照名称注入。它在给类成员注入时不能单独使用，必须和@Autowired同时使用。但是在给方法参数注入时可以单独使用属性：     value：用于指定注入bean的id例子：    @Autowired    @Qualifier(&quot;accountDaoImpl&quot;)    private IAccountDao accountDaoImpl;</code></pre><h6 id="3-Resource"><a href="#3-Resource" class="headerlink" title="3.@Resource"></a>3.@Resource</h6><pre><code>作用：直接按照bean的id注入，可以单独使用属性：    name：用于指定bean的id例子：    @Resource(name = &quot;accountDaoImpl&quot;)    private IAccountDao accountDaoImpl;</code></pre><p><strong>注意：</strong> 以上三个注解，只能注入其他bean类型的数据，集合类型的注入只能通过xml来实现</p><h6 id="4-Value"><a href="#4-Value" class="headerlink" title="4.@Value"></a>4.@Value</h6><pre><code>作用：用于注入基本类型和String类型的数据属性：    value：    用于指定数据的值。它可以使用spring中的SpEL（也就是spring中的el表达式）    SpEl写法： ${表达式}    注意：     el表达式在哪里，就是谁的el表达式，如果出现在jsp里面，就是jsp的el表达式，如果写在spring的配置文件中就是spring的el表达式，如果写在mybatis的配置文件中，那么就是mybatis的配置文件中</code></pre><h4 id="四-作用范围相关"><a href="#四-作用范围相关" class="headerlink" title="四.作用范围相关"></a>四.作用范围相关</h4><p>他们的作用就和在bean标签中使用scope属性实现的功能是一样的</p><h6 id="1-Scope"><a href="#1-Scope" class="headerlink" title="1.@Scope"></a>1.@Scope</h6><pre><code> 作用：用于指定bean的作用范围 位置：类 属性：     value：指定范围的取值。取值和xml中bean标签中的scope属性一样，常用取值为singleton prototype，默认值是singleton</code></pre><h4 id="五-生命周期相关"><a href="#五-生命周期相关" class="headerlink" title="五.生命周期相关"></a>五.生命周期相关</h4><p>他们的作用就和在bean标签中使用init-method和destroy-method的作用是一样的</p><h6 id="1-PreDestroy"><a href="#1-PreDestroy" class="headerlink" title="1.@PreDestroy"></a>1.@PreDestroy</h6><pre><code>作用：用于指定销毁方法</code></pre><h6 id="2-PostConstruct"><a href="#2-PostConstruct" class="headerlink" title="2.@PostConstruct"></a>2.@PostConstruct</h6><pre><code>作用：用于指定初始化方法</code></pre><p><strong>用法：</strong>在bean类中，定义init()方法，用PostConstruct注解，定义destory()方法，用ProDestroy注解，bean对象在创建时候会执行init()方法，在销毁时会执行destroy()方法</p><h2 id="xml和注解相结合的IoC"><a href="#xml和注解相结合的IoC" class="headerlink" title="xml和注解相结合的IoC"></a>xml和注解相结合的IoC</h2><p>就是在applicationContext.xml文件中<code>&lt;context:component-scan/&gt;</code>和<code>&lt;bean/&gt;</code>一起使用<br>自定义类可以用注解也就是扫描包的形式加入IoC，而外部的包中的类可以用<code>&lt;bean/&gt;</code>标签来加入IoC</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;       http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;&lt;!--告知spring在创建容器的时候要扫描的包，配置所需要的标签不是在beans的约束中，    而是一个名称为context名称空间和约束中--&gt;&lt;context:component-scan base-package=&quot;com.cbw&quot;&gt;&lt;/context:component-scan&gt;&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><h2 id="纯注解的IoC"><a href="#纯注解的IoC" class="headerlink" title="纯注解的IoC"></a>纯注解的IoC</h2><p><strong>根据xml配置文件获取容器</strong><br>ApplicationContext ac = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>//这个同理，也可以传xml配置文件数组<br><strong>根据配置类获取容器</strong><br>ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);<br>//该构造方法可以传字节码数组，也就意味着，如果你有多个配置类，你都不想加@Configuration注解，那么就一起传进构造方法，用，隔开</p><h6 id="1-创建一个Configuration类"><a href="#1-创建一个Configuration类" class="headerlink" title="1.创建一个Configuration类"></a>1.创建一个Configuration类</h6><pre><code>作用：配置类，相当于applicationContext.xml文件</code></pre><h6 id="2-Configuration"><a href="#2-Configuration" class="headerlink" title="2.@Configuration"></a>2.@Configuration</h6><pre><code>作用：指定当前类是一个配置类细节：当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注释可以不写，如果有多个配置类，不作为参数的配置类必须加上这个注解，且要在@ComponentScan注解中加入这个配置类，否则，扫描包的时候，spring不会去扫描该类下的其他注解</code></pre><h6 id="3-ComponentScan"><a href="#3-ComponentScan" class="headerlink" title="3.@ComponentScan"></a>3.@ComponentScan</h6><pre><code>作用：用于通过注释指定spring在创建容器时要扫描的包，相当于applicationContext.xml文件中&lt;context:component-scan/&gt;标签属性：    basePackage：用于指定创建容器时要扫描的包    value：它和basePackages的作用一样注意：    1.这两个都是数组类型的，一个类的时候，直接写，多个类要用{}隔开        @ComponentScan(basePackages = {&quot;com.cbw&quot;,&quot;com.cbw.domain&quot;})    2.basePackage和value也可以不写，直接写字符串        @ComponentScan(&quot;com.cbw&quot;)</code></pre><h6 id="4-Bean"><a href="#4-Bean" class="headerlink" title="4.@Bean"></a>4.@Bean</h6><pre><code>作用：用于把当前方法的返回值作为bean对象存入spring的核心容器中属性：    name：用于指定bean的id，当不写时，默认值是当前方法的名称细节：当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象，查找方式和@AutoWired注解是一样的</code></pre><h6 id="5-Import"><a href="#5-Import" class="headerlink" title="5.@Import"></a>5.@Import</h6><pre><code>作用：用来导入其他的配置类位置：主配置类属性：    value：用于指定其他配置类的字节码，是个数组细节：    当我们使用import注解之后，有import注解的类就是父配置类，而导入的都是子配置类，而我们如果通过ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class)构造方法传入多个配置类，那他们就是并列关系，推荐使用第一种</code></pre><h6 id="6-PropertySource与-PropertySources"><a href="#6-PropertySource与-PropertySources" class="headerlink" title="6.@PropertySource与@PropertySources"></a>6.@PropertySource与@PropertySources</h6><pre><code>作用：用于指定properties文件的位置位置：主配置类属性：    value：指定文件的名称和路径    关键字：classpath，表示类路径下，如果properties文件在包中，可以再加上包路径格式：@PropertySource(&quot;classpath:jdbc.properties&quot;),@PropertySource(&quot;classpath:包/包/jdbc.properties&quot;)细节：前者只能传一个properties文件，后者可以传properties文件数组</code></pre><h6 id="7-例子"><a href="#7-例子" class="headerlink" title="7.例子"></a>7.例子</h6><pre><code>@Configuration@ComponentScan(&quot;com.cbw&quot;)public class SpringConfiguration { /** * 用于创建一个QueryRuanner对象，并且存入springIoC容器中 * @param dataSource * @return */@Bean(&quot;runner&quot;)public QueryRunner createQueryRunner(DataSource dataSource){    return new QueryRunner(dataSource);}/** * 用于创建一个数据源对象，并且存入springIoC容器中 * @return */@Bean(&quot;dataSource&quot;)public DataSource createDataSource(){    ComboPooledDataSource ds = new ComboPooledDataSource();    try {        ds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);        ds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/myspringspace?useUnicode=true&amp;characterEncoding=utf8&quot;);        ds.setUser(&quot;root&quot;);        ds.setPassword(&quot;123456&quot;);    } catch (PropertyVetoException e) {        e.printStackTrace();    }    return ds;}}</code></pre><h2 id="spring整合Junit"><a href="#spring整合Junit" class="headerlink" title="spring整合Junit"></a>spring整合Junit</h2><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>实际开发中，开发和测试是分开的，测试类中只能有测试方法，就像这样<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200309221158590/20200317121953825.png" alt><br>而创建容器或者初始化对象都是没有的，这就引出来一串问题</p><h6 id="1-程序的入口"><a href="#1-程序的入口" class="headerlink" title="1.程序的入口"></a>1.程序的入口</h6><pre><code>main()方法</code></pre><h6 id="2-Junit单元测试中，没有main方法也能执行"><a href="#2-Junit单元测试中，没有main方法也能执行" class="headerlink" title="2.Junit单元测试中，没有main方法也能执行"></a>2.Junit单元测试中，没有main方法也能执行</h6><pre><code>原因：Junit集成了一个main方法，该方法会判断当前测试类中哪些方法有@Test注解，Junit会让有注解的方法执行</code></pre><h6 id="3-Junit不会管我们是否采用spring框架"><a href="#3-Junit不会管我们是否采用spring框架" class="headerlink" title="3.Junit不会管我们是否采用spring框架"></a>3.Junit不会管我们是否采用spring框架</h6><pre><code>在执行测试方法时，Junit根本不知道我们是不是使用了spring框架，所以就不会为我们读取配置文件/配置类创建spring核心容器</code></pre><h6 id="4-结论"><a href="#4-结论" class="headerlink" title="4.结论"></a>4.结论</h6><pre><code>    当测试方法执行时，没有IoC容器，就算写了@Autowired注解，也无法实现注入</code></pre><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><h5 id="1-导入spring整合Junit的jar包-坐标"><a href="#1-导入spring整合Junit的jar包-坐标" class="headerlink" title="1.导入spring整合Junit的jar包(坐标)"></a>1.导入spring整合Junit的jar包(坐标)</h5><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h5 id="2-使用Junit提供的一个注解替换原来Junit集成的main-方法，替换成spring提供的-Runwith注解"><a href="#2-使用Junit提供的一个注解替换原来Junit集成的main-方法，替换成spring提供的-Runwith注解" class="headerlink" title="2.使用Junit提供的一个注解替换原来Junit集成的main()方法，替换成spring提供的@Runwith注解"></a>2.使用Junit提供的一个注解替换原来Junit集成的main()方法，替换成spring提供的@Runwith注解</h5><p>意思就是，Junit提供了一个注解替换自己的main方法，将它替换成spring提供的@Runwith注解<br><code>@RunWith</code>标签</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)public class accountTest2 {    private IAccountService accountService;    ~    ~    一堆测试方法    ~    ~}</code></pre><h5 id="3-告知spring的运行器，spring和ioc创建是基于xml还是注解的，并且说明位置"><a href="#3-告知spring的运行器，spring和ioc创建是基于xml还是注解的，并且说明位置" class="headerlink" title="3.告知spring的运行器，spring和ioc创建是基于xml还是注解的，并且说明位置"></a>3.告知spring的运行器，spring和ioc创建是基于xml还是注解的，并且说明位置</h5><p><code>@ContextConfiguration</code>标签</p><pre><code>属性:    locations：指定xml文件的位置，加上classpath关键字，表示在类路径下    classes：指定注解类（配置类）所在地位置</code></pre><h6 id="注意：spring版本为5-x版本时，要求Junit的版本必须是4-12及以上"><a href="#注意：spring版本为5-x版本时，要求Junit的版本必须是4-12及以上" class="headerlink" title="注意：spring版本为5.x版本时，要求Junit的版本必须是4.12及以上"></a>注意：spring版本为5.x版本时，要求Junit的版本必须是4.12及以上</h6><h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><p>使用注解：</p><pre><code>/** * 使用junit单元测试测试我们的配置 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfiguration.class)public class accountTest2 {    private IAccountService accountService;    /**     * 测试查询所有方法     */    @Test    public void testFindAll(){        //3.执行方法        List&lt;Account&gt; accountList = accountService.findAllAccount();        for (Account aclist:accountList             ) {            System.out.println(aclist);        }    }}</code></pre><p>使用xml文件：</p><pre><code>/** * 使用junit单元测试测试我们的配置 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)public class accountTest2 {    @Autowired    private IAccountService accountService = null;    /**     * 测试查询所有方法     */    @Test    public void testFindAll(){        //3.执行方法        List&lt;Account&gt; accountList = accountService.findAllAccount();        for (Account aclist:accountList             ) {            System.out.println(aclist);        }    }}    </code></pre></h4>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java对象的内存</title>
      <link href="/2020/02/11/java%E5%AD%A6%E4%B9%A0--%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98/"/>
      <url>/2020/02/11/java%E5%AD%A6%E4%B9%A0--%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一个对象的内存"><a href="#一个对象的内存" class="headerlink" title="一个对象的内存"></a>一个对象的内存</h1><p>首先要了解java中的内存分配机制</p><pre><code>栈（stack）：存放的都是方法中的局部变量，方法的运行在栈当中        局部变量：方法的参数，或者视方法体内部的变量        作用域：一旦超出作用域，立即从栈内存中消失堆（Heap）：凡是new出来的东西，都在堆当中。        堆内存里面的东西都有一个地址值：16进制的        堆内存里面的东西都有一个默认值。方法区（Method Area）：存储.class相关信息，包含方法的信息本地方法栈（Native Method Stack）：与操作系统相关寄存器（pc register）：与cpu相关</code></pre><p>用一个手机对象为例细说对象内存<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200211142733842/20200211023718046.png" alt><br>当程序运行的时候，首先方法区中会存放类的相关信息，和方法的相关信息<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/20200211142733842/20200211024234927.png" alt><br>如图，程序中两个class信息都存在方法区，当new出来一个phone时，将它存放在堆内存里面，而我们调用one.什么什么的时候，这些都算是main方法中的局部变量，所以是存在于栈内存中的</p><h4 id="程序中如果调用one-brand-“苹果”，他有2个步骤"><a href="#程序中如果调用one-brand-“苹果”，他有2个步骤" class="headerlink" title="程序中如果调用one.brand = “苹果”，他有2个步骤"></a>程序中如果调用one.brand = “苹果”，他有2个步骤</h4><p>1.该指令存放在栈里面<br>2.根据one对象的地址，到堆内存中寻找one对象的信息，再进行修改</p><h4 id="当调用one-call-“乔布斯”-这个方法时，他有"><a href="#当调用one-call-“乔布斯”-这个方法时，他有" class="headerlink" title="当调用one.call(“乔布斯”)这个方法时，他有"></a>当调用one.call(“乔布斯”)这个方法时，他有</h4><p>1.该指令存放在栈里面<br>2.根据one对象的地址，到堆内存中寻找one对象的信息<br>3.根据one对象的方法的地址，到方法区中寻找具体的方法<br>4.将该方法指令压入栈内存中，然后执行，执行完毕就出栈</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/java%E5%AD%A6%E4%B9%A0--%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98/20200211045052020.png" alt><br>1.最开始main方法就是在栈中的，当main方法执行完毕，从栈中弹出，也就意味着程序运行完毕。<br>2.同一个类的不同对象的方法，是共用同一个方法区中的方法的，地址相同。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小科普</title>
      <link href="/2019/04/18/%E5%B0%8F%E7%A7%91%E6%99%AE/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%A4%E6%96%AD%E9%97%B0%E5%B9%B4%E4%B8%8D%E8%83%BD%E5%8D%95%E5%8D%95%E7%9C%8B%E8%BF%99%E4%B8%80%E5%B9%B4%E6%98%AF%E5%90%A6%E4%B8%BA4%E7%9A%84%E5%80%8D%E6%95%B0/"/>
      <url>/2019/04/18/%E5%B0%8F%E7%A7%91%E6%99%AE/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%A4%E6%96%AD%E9%97%B0%E5%B9%B4%E4%B8%8D%E8%83%BD%E5%8D%95%E5%8D%95%E7%9C%8B%E8%BF%99%E4%B8%80%E5%B9%B4%E6%98%AF%E5%90%A6%E4%B8%BA4%E7%9A%84%E5%80%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么判断闰年不能单单看这一年是否为4的倍数"><a href="#为什么判断闰年不能单单看这一年是否为4的倍数" class="headerlink" title="为什么判断闰年不能单单看这一年是否为4的倍数"></a>为什么判断闰年不能单单看这一年是否为4的倍数</h1><h3 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h3><p>地球绕太阳运行周期为365天5小时48分46秒（合365.24219天）即一回归年。公历的平年只有365日，比回归年短约0.2422 日，所余下的时间约为四年累计一天，故四年于2月加1天，使当年的历年长度为366日，这一年就为闰年。现行公历中每400年有97个闰年。按照每四年一个闰年计算，平均每年就要多算出0.0078天，这样经过四百年就会多算出大约3天来。因此每四百年中要减少三个闰年。所以公历规定：年份是整百数时，必须是400的倍数才是闰年；不是400的倍数的年份，即使是4的倍数也不是闰年。</p><h3 id="因此"><a href="#因此" class="headerlink" title="因此"></a>因此</h3><p>我们判断闰年，需要这样写<br><code>year%400 == 0||year%4 == 0&amp;&amp;year%100 != 0</code></p>]]></content>
      
      
      <categories>
          
          <category> 小科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小科普 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习--小实验</title>
      <link href="/2019/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--%E5%B0%8F%E5%AE%9E%E9%AA%8C/"/>
      <url>/2019/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--%E5%B0%8F%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="大数据学习"><a href="#大数据学习" class="headerlink" title="大数据学习"></a>大数据学习</h1><h2 id="–-小实验"><a href="#–-小实验" class="headerlink" title="– 小实验"></a>– 小实验</h2><blockquote><blockquote><p>环境：<br>idea：ultimate 2018.1<br>系统：windows10 家庭版</p></blockquote></blockquote><h3 id="1-Count计数器"><a href="#1-Count计数器" class="headerlink" title="1.Count计数器"></a>1.Count计数器</h3><p><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--%E5%B0%8F%E5%AE%9E%E9%AA%8C/20190409114549258.png" alt></p><h3 id="2-自定义计数器"><a href="#2-自定义计数器" class="headerlink" title="2.自定义计数器"></a>2.自定义计数器</h3><h5 id="1-枚举类型"><a href="#1-枚举类型" class="headerlink" title="(1)枚举类型"></a>(1)枚举类型</h5><p>在mapper中定义<strong>CustomCount</strong>枚举类型</p><pre><code>enum CustomCount{            MAP_RUN_COUNT;        }</code></pre><p>然后在map方法中写<br><code>context.getCounter(CustomCount.MAP_RUN_COUNT).increment(1l);</code><br>后面的increment是增加count值的，参数是1l，参数类型是long<br>计数结果<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--%E5%B0%8F%E5%AE%9E%E9%AA%8C/20190409114918456.png" alt></p><h5 id="2-键值对类型"><a href="#2-键值对类型" class="headerlink" title="(2)键值对类型"></a>(2)键值对类型</h5><p>在reducer中定义<br><code>context.getCounter(&quot;REDUCE_RUN_COUNTS&quot;,&quot;running_counts&quot;).increment(1l);</code><br>使用键值对形式定义计数器<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--%E5%B0%8F%E5%AE%9E%E9%AA%8C/20190411010954240.png" alt></p><h3 id="3-局部合并"><a href="#3-局部合并" class="headerlink" title="3.局部合并"></a>3.局部合并</h3><p>combiner和reducer的区别在于运行的位置：</p><ol><li>Combiner是在每一个maptask所在的节点运行</li><li>Reducer是接受全局所有Mapper的输出结果</li><li>Combiner的意义就是对每一个maptask的输出进行局部汇总，以减少网络传输量</li></ol><p><strong>具体步骤：</strong></p><h5 id="自定义一个Combiner类继承Reducer类，重写reduce方法"><a href="#自定义一个Combiner类继承Reducer类，重写reduce方法" class="headerlink" title="自定义一个Combiner类继承Reducer类，重写reduce方法"></a>自定义一个Combiner类继承Reducer类，重写reduce方法</h5><h5 id="在job中设置-job-setCombinerClass-CustomCombiner-class"><a href="#在job中设置-job-setCombinerClass-CustomCombiner-class" class="headerlink" title="在job中设置:job.setCombinerClass(CustomCombiner.class);"></a>在job中设置:<code>job.setCombinerClass(CustomCombiner.class)</code>;</h5><p><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--%E5%B0%8F%E5%AE%9E%E9%AA%8C/20190411011941037.png" alt><br>这是没有设置Combiner<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--%E5%B0%8F%E5%AE%9E%E9%AA%8C/20190411012753265.png" alt><br>这是设置了Combiner<br>可以明显的看到reduce的输入次数和shuffle过程的字节数有所减少<br><strong><em>注意：求平均值得业务不适用局部聚合，这样会使结果不准确</em></strong></p><h3 id="4-对象封装"><a href="#4-对象封装" class="headerlink" title="4.对象封装"></a>4.对象封装</h3>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习--zookeeper</title>
      <link href="/2019/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--zookeeper/"/>
      <url>/2019/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--zookeeper/</url>
      
        <content type="html"><![CDATA[<h1 id="大数据学习"><a href="#大数据学习" class="headerlink" title="大数据学习"></a>大数据学习</h1><h2 id="–zookeeper"><a href="#–zookeeper" class="headerlink" title="–zookeeper"></a>–zookeeper</h2><blockquote><blockquote><p>环境：<br>zookeeper：3.4.8<br>系统：centos 6.7</p></blockquote></blockquote><h3 id="1-zookeeper简介"><a href="#1-zookeeper简介" class="headerlink" title="1.zookeeper简介"></a>1.zookeeper简介</h3><h5 id="a-简介"><a href="#a-简介" class="headerlink" title="a.简介"></a>a.简介</h5><p>zookeeper是一个分布式协调服务,是给用户的分布式应用程序提供协调服务的，他的服务目标是分布式程序<br>zookeeper本身就是一个分布式程序，只要有半数以上的节点存活，zk就能正常运行<br>zookeeper所提供的服务有：主从协调、服务器节点动态上下线、统一配置管理、分布式共享锁、统一名称服务等等<br>zookeeper底层实质只提供两个服务：</p><ol><li>管理(存储，读取)用户程序提交的数据</li><li>为用户程序提供数据节点监听服务</li></ol><h5 id="b-角色描述"><a href="#b-角色描述" class="headerlink" title="b.角色描述"></a>b.角色描述</h5><ol><li>Leader：领导者，负责进行投票的发起和决议，更新系统状态</li><li>Learner：<ul><li>Follower：用于接受客户请求并向客户端返回结果，在选主过程参与投票</li><li>Observer：接受用户请求，将请求转发给leader节点，但不参与投票，只同步Leader的状态，增加这个角色目的是为了扩展系统，提高读取速度</li></ul></li><li>Client：请求发起方</li></ol><p>zookeeper采用的方式是写任意。通过增加机器，他的吞吐能力和响应能力扩展性非常好，而且，随着机器的增多吞吐能力肯定下降(这也是它建立Observer的原因)，而响应能力取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。</p><h5 id="c-特性"><a href="#c-特性" class="headerlink" title="c.特性"></a>c.特性</h5><ul><li>zookeeper：一个Leader，多个Follower相组成的集群</li><li>全局数据一致：每个server保存一份相同的数据副本，client无论连接到哪个server，数据都是一致的</li><li>分布式读写：更新请求转发，由Leader实施</li><li>更新请求顺序执行：来自同一个client的更新请求按其发送顺序依次执行</li><li>数据更新原子性：一次数据更新要么成功，要么失败</li><li>实时性：在一定时间范围内，client能读到最新数据</li></ul><h6 id="Server三种状态"><a href="#Server三种状态" class="headerlink" title="Server三种状态"></a>Server三种状态</h6><p>每个server在工作过程中有三种状态：<br><strong>LOOKING</strong>：当前Server不知道Leader是谁，正在搜寻<br><strong>LEADING</strong>：当前Server即为选举出的Leader<br><strong>FOLLOWING</strong>：leader已经选举出来，当前Server与之同步</p><h6 id="zookeeper选举流程"><a href="#zookeeper选举流程" class="headerlink" title="zookeeper选举流程"></a>zookeeper选举流程</h6><p>leader崩溃或者失去大多数follower时，zk进入恢复模式，重新选举出一个新的leader，让所有的server都恢复到一个正确的状态。zk的选举算法有两个：</p><ul><li>基于basic paxos算法实现</li><li>基于fast paxos算法实现</li></ul><p>系统默认的选举算法为fast paxos算法。</p><h5 id="d-zookeeper数据结构"><a href="#d-zookeeper数据结构" class="headerlink" title="d.zookeeper数据结构"></a>d.zookeeper数据结构</h5><p><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--zookeeper/20190412030737237.png" alt></p><ul><li>层次化的目录结构，命名符合常规文件系统规范</li><li>每个节点在zookeeper中叫做znode，并且其有一个唯一的路径标识</li><li>节点Znode可以包含数据和子节点(ephemeral类型节点不能有子节点)</li><li>客户端应用可以在节点上设置监视器<blockquote><blockquote><p>监视器：客户端可以在节点上设置watch，我们叫监视器，当节点状态发生改变的时候，如数据的增、删、改，将会触发监视器，这是，zk会向客户端发送且仅发送一条通知，因为watch只能触发一次，触发后就被销毁了<br>Znode有两种类型</p><ul><li>短暂(ephemeral):server断开连接时自己删除</li><li>持久(persistent)server断开连接不删除</li></ul><p>Znode有四种形式的目录节点(默认是persistent)</p><ul><li>PERSISTENT</li><li>PERSISTENT_SEQUENTIAL(持久序列/test0000000019)</li><li>EPHENERAL</li><li>EPHENERAL_SEQUENTIAL<br>创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护。在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序</li></ul></blockquote></blockquote></li></ul><hr><h3 id="2-zookeeper的安装与配置"><a href="#2-zookeeper的安装与配置" class="headerlink" title="2.zookeeper的安装与配置"></a>2.zookeeper的安装与配置</h3><p><a href="http://archive.apache.org/dist/zookeeper/" target="_blank" rel="noopener">zookeeper下载地址</a><br>我们下载zookeeper-3.4.8<br>上传，解压到/usr/目录<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--zookeeper/20190411043446357.png" alt><br><strong>配置</strong><br>首先配置环境变量<br><code>vim /etc/profile</code><br>我们在文件尾加上</p><pre><code>export ZOOKEEPER_HOME=/usr/zookeeper-3.4.8export PATH=$PATH:$ZOOKEEPER/bin    </code></pre><p><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--zookeeper/20190411043919117.png" alt><br>然后别忘了<code>source /etc/profile</code><br>然后我们需要配置/zookeeper-3.4.8/conf/zoo.cfg文件<br><code>vim /usr/zookeeper-3.4.8/conf/zoo.cfg</code><br>我们在文件末加入</p><pre><code>dataDir= /usr/zookeeper-3.4.8/datadataLogDir= /usr/zookeeper-3.4.8/logserver.1=cbw:2888:3888server.2=cbw1:2888:3888server.3=cbw2:2888:3888</code></pre><p><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--zookeeper/20190411050411254.png" alt><br>dataDir有时候zookeeper自带，我们就不需要加，我们加上后面的就行<br><strong><em>注意：cbw：主机名，2888：心跳端口，3888数据端口</em></strong><br>我们只需要修改主机名就行，然后<strong>server.x</strong>这个<strong>x</strong>表示你有多少台服务器，比如我有<strong>3</strong>台，我就要写到<strong>server.3</strong>，然后每个后面的主机名都要改成那台服务器的主机名。<br>之后，我们需要到/usr/zookeeper-3.4.8/目录下创建data和log这两个文件夹，有时候zookeeper自带了data，那么我们只需要创建log文件夹就行</p><pre><code>mkdir -m 755 datamkdir -m 755 log</code></pre><p>然后我们在data目录下创建myid文件,并向其中写入<strong>1</strong></p><pre><code>touch myidvim myid</code></pre><p><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--zookeeper/20190411050511388.png" alt><br>最后一步，分发</p><pre><code>scp /etc/profile cbw1:/etcscp -r /usr/zookeeper-3.4.8 cbw1:/usr</code></pre><p>然后到cbw1这台机上<br><code>source /etc/profile</code><br>并且修改<strong>myid</strong>文件<br><code>vim /usr/zookeeper-3.4.8/data/myid</code><br>修改内容为2，因为我们在zoo.cfg中写的，cbw1对应的是server.2<br>同理cbw2也是要这样写，这样我们zookeeper集群就搭建完毕</p><h3 id="3-zookeeper命令"><a href="#3-zookeeper命令" class="headerlink" title="3.zookeeper命令"></a>3.zookeeper命令</h3><p>启动zookeeper服务<br><code>zkServer.sh start</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--zookeeper/20190411050252384.png" alt><br>查看zookeeper状态<br><code>zkServer.sh status</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--zookeeper/20190411050157588.png" alt><br>停止zookeeper服务<br><code>zkServer.sh stop</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--zookeeper/20190411050320751.png" alt><br>连接<br><code>zkCli.sh</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--zookeeper/20190412034148480.png" alt><br>Create命令<br><code>create [-e] [-s] path data acl</code></p><ul><li>path指定节点路径</li><li>data指定需要存放的数据(状态信息)<br>创建临时节点<br><code>create -e</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--zookeeper/20190412034346518.png" alt><br><strong><em>注意：临时节点是不能有子节点的</em></strong><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--zookeeper/20190412034724869.png" alt><br>创建永久节点<br><code>create /zk_test data</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--zookeeper/20190412035421447.png" alt><br>创建临时有序节点<br><code>create -e -s /zk_test data</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--zookeeper/20190412035705710.png" alt><br>创建永久有序节点<br><code>create -s /zk_test data</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--zookeeper/20190412035728242.png" alt><br>删除节点<br><code>delete /zk_test</code><br><code>rmr /zk_test</code><br><strong><em>注意：delete不能删除节点下不为空的节点，而rmr可以递归删除</em></strong><br>我们在永久的节点下面创建有序永久节点，如果我们之前在/zk_test下面有3个临时的有序节点，之后客户端断开之后被删除，这个时候你再这个节点创建有序节点的时候，编号不是从0开始，而是从你之前的序号之后开始递增。<h3 id="4-zookeeper-ACL"><a href="#4-zookeeper-ACL" class="headerlink" title="4.zookeeper ACL"></a>4.zookeeper ACL</h3></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习--MapReduce程序编写</title>
      <link href="/2019/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--MapReduce%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99/"/>
      <url>/2019/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--MapReduce%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="大数据学习"><a href="#大数据学习" class="headerlink" title="大数据学习"></a>大数据学习</h1><h2 id="–MapReduce程序编写"><a href="#–MapReduce程序编写" class="headerlink" title="–MapReduce程序编写"></a>–MapReduce程序编写</h2><blockquote><blockquote><p>环境：<br>idea: ultimate 2018.1</p></blockquote></blockquote><p>运行流程示意图<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--MapReduce%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99/20190406011925824.png" alt><br>以wordCount为例</p><h3 id="Mapper："><a href="#Mapper：" class="headerlink" title="Mapper："></a>Mapper：</h3><p>数据输入进来的第一步，可以定制键值对<br>Mapper类需要继承Mapper父类</p><pre><code>public static class WordCountMapper extends Mapper&lt;LongWritable,Text,Text,IntWritable&gt;{protected void map(LongWritable key,Text value, Context context) throws IOException, InterrupteException{        String[] words = value.toString().split(&quot;,&quot;);        for(String word:words){            context.write(new Text(word),new IntWritable(1));        }    }}</code></pre><p><strong>Mapper</strong>父类一共有4个参数<br>1：是数据的偏移量，例如刚进来为0，第二次进来因为已经读完了一行数据，他就等于第一行数据的长度+0，以此类推<br>2：表示下一行数据，在这个例子里面是一行的字符，也就是下面map方法中的value<br>3：输出的key的数据类型<br>4：这个表示map方法产生的value类型，在我们这个例子中是IntWritable型的，所以我们继承的时候要写IntWritable</p><p><strong>map</strong>方法一共有3个参数<br>LongWritable key：偏移量<br>Text value：输入的这行的数据<br>Context：存储map运算后的数据，本例子中<code>context.write(new Text(word),new IntWritable(1))</code>,key是字母，value则为1，因为         字母出现一次就记一次</p><h3 id="Reducer："><a href="#Reducer：" class="headerlink" title="Reducer："></a>Reducer：</h3><p>由流程图可以看出这是最后一步，就是总结的作用吧，汇总所有数据，然后进行输出<br>Reducer类需要继承Reducer父类</p><pre><code>    public static class HadoopReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {        //相同的key聚合 几种类型的key调用reduce几次        private IntWritable count = new IntWritable();        @Override        protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException {            int sum = 0;            for (IntWritable value : values) {                sum += value.get();            }            count.set(sum);            context.write(key, count);        }    }</code></pre><p><strong>Reducer</strong>父类一共有4个参数<br>1：输入的key数据类型，本例中是字母，我们用Text存储<br>2：输入的value数据类型，本例中是频率，我们用IntWritable来存储<br>3：输出key的数据类型<br>4：这个表示reduce方法产生的value类型，在我们这个例子中是IntWritable型的，所以我们继承的时候要写IntWritable<br><strong>reduce</strong>方法一共有3个参数<br>Text key：map运算设置的key<br>Iterable<intwritable> value：这是key相同的value的聚合，本例中因为key是字母，value都是1，所以在这里是这样，如，key=a,如                              果里面有3个a，那么这个value中就是{1,1,1}，这个是迭代式的形式<br>Context：存储reduce运算后的数据，本例子中<code>context.write(new Text(word),new IntWritable(1))</code>,key是字母，value则为频          率</intwritable></p><h3 id="main方法测试"><a href="#main方法测试" class="headerlink" title="main方法测试"></a>main方法测试</h3><pre><code>        Configuration config = new Configuration(); //初始化配置        Job job = Job.getInstance(config);//把任务封装到job对象        job.setJarByClass(HadoopDriver.class);//设置任务启动类        job.setMapperClass(HadoopMapper.class);//设置mapper类        job.setReducerClass(HadoopReducer.class);//设置reducer类        //设置输出的key和value的数据类型， 如果map的输出和reduce输出key-value类型一致  可以不写map        job.setMapOutputKeyClass(Text.class);        job.setMapOutputValueClass(IntWritable.class);        job.setOutputKeyClass(Text.class);        job.setOutputValueClass(IntWritable.class);        //告诉hadoop集群以什么方式读取数据，从哪里读取        job.setInputFormatClass(TextInputFormat.class);//设置输入格式，默认是key-value输入        TextInputFormat.setInputPaths(job, new Path(&quot;D:\\word.txt&quot;));//设置输入目录，本例也就是需要统计字频的文件        //告诉hadoop集群以什么样的方式写入数据，数据写入到哪里        job.setOutputFormatClass(TextOutputFormat.class);//设置输出格式，默认是key-value输出        Path path = new Path(&quot;D:\\wordcount&quot;);//新建路径        FileSystem fs = FileSystem.get(config);//新建文件系统        if (fs.exists(path)) {//判断路径是否存在，如果存在则删除，hadoop的严格的容错性保证每次输出一定是新目录            fs.delete(path, true);        }        TextOutputFormat.setOutputPath(job, path);//设置输出路径        //提交任务        System.exit(job.waitForCompletion(true) ? 0 : 1);//当任务完成时，系统退出</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> MapReduce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习--Idea与Maven的安装与配置</title>
      <link href="/2019/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="大数据学习"><a href="#大数据学习" class="headerlink" title="大数据学习"></a>大数据学习</h1><h2 id="–idea与maven的安装与配置"><a href="#–idea与maven的安装与配置" class="headerlink" title="–idea与maven的安装与配置"></a>–idea与maven的安装与配置</h2><blockquote><blockquote><p>环境：<br>idea：ultimate 2018.3<br>maven：3.3.9</p></blockquote></blockquote><h3 id="1-idea的安装与配置"><a href="#1-idea的安装与配置" class="headerlink" title="1.idea的安装与配置"></a>1.idea的安装与配置</h3><p><a href="http://www.jetbrains.com/idea/download/#section=windows" target="_blank" rel="noopener">idea下载地址</a><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326030342882.png" alt><br>选择ultimate版本下载，这只能免费试用，所有我们需要破解，或者申请资格，我是使用学生身份申请一年的使用权<br><strong>开始安装</strong><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326010349306.png" alt><br>选择安装位置<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326010524893.png" alt><br>根据自己的电脑配置选择启动器位数，第一个是在桌面创建一个快捷方式，第二个是选择是否在菜单上增加<code>Open Folder as Project</code>功能，<strong>可√可不√</strong>，第三个是创建文件关联，<strong>可以√也可以不√</strong>，第四个如果电脑jdk环境已经配置了，<strong>可以不√</strong>，一般jdk中有jre，第五个是添加启动器目录到路径，<strong>可√可不√</strong><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326010915397.png" alt><br>下一步，选择开始菜单的文件夹，可以是默认的JetBrains，这样你在开始菜单找J字母，可以找到这个文件夹，里面就有idea<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326011543602.png" alt><br>点击Install，开始安装，等待<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326011626758.png" alt><br>选择重启完成安装<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326012623459.png" alt><br>导入设置文件，但是我们是第一次安装，就选第二个<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326013300882.png" alt><br>同一用户协议<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326013335195.png" alt><br>是否分享数据给JetBrains公司，可以也不可以，自己选择<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326013551923.png" alt><br>设置主题<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326013737527.png" alt><br>选择你要使用的功能，java默认启用了，可以直接下一步<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326013856004.png" alt><br>安装插件，也可以直接下一步<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326013930517.png" alt><br>如果你购买了，可以登录账号，这里我们选择免费试用，只有30天的时间<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326014135892.png" alt><br>到了这一步安装完成了，可以开始使用了<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326014259782.png" alt></p><h3 id="2-maven的安装与配置"><a href="#2-maven的安装与配置" class="headerlink" title="2.maven的安装与配置"></a>2.maven的安装与配置</h3><p><a href="https://archive.apache.org/dist/maven/maven-3/" target="_blank" rel="noopener">maven下载地址</a><br>选择相应版本下载， 这里我们选择3.3.9版本<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326022647784.png" alt><br>下载好了后，解压，放到自己选择的文件夹里面，下一步</p><h4 id="环境变量的配置"><a href="#环境变量的配置" class="headerlink" title="环境变量的配置"></a>环境变量的配置</h4><p>右键我的电脑<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326023116153.png" alt><br>属性-&gt;高级系统设置<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326023146845.png" alt><br>环境变量<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326023202538.png" alt><br>在系统变量里面新建，然后设置<br><code>MAVEN_HOME= &lt;maven根目录&gt;</code><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190327093339417.png" alt><br>然后在Path里面新建，写上<br><code>%MAVEN_HOME%\bin</code><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326023440279.png" alt><br>确定之后，去cmd输入<br><code>mvn -v</code><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326023638470.png" alt><br>出现这个界面，说明maven配置已经完成</p><h4 id="修改资源库"><a href="#修改资源库" class="headerlink" title="修改资源库"></a>修改资源库</h4><p>maven会自动给你下载所需要的jar包， 他默认是从apach的仓库下载，这里我们可以修改仓库，用阿里云或者其他近一点的仓库，这样下载速度会快一些，提高我们的工作效率<br>进入maven根目录<br><code>maven-&gt;conf-&gt;setting.xml</code></p><blockquote><blockquote><p>这个文件要用notepad，或者其他编辑器打开，如果用记事本，里面的东西会很密集，这让修改起来会异常麻烦</p></blockquote></blockquote><p>我们找到<strong>mirrors</strong>标签，写入以下代码</p><pre><code>&lt;mirror&gt;    &lt;id&gt;alimaven&lt;/id&gt;     &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;     &lt;name&gt;aliyun maven&lt;/name&gt;     &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;&lt;/mirror&gt;</code></pre><p><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8Emaven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326030131047.png" alt><br>这代表我们从阿里云的maven仓库下载jar包，修改完成保存退出。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Idea </tag>
            
            <tag> 大数据 </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习--Idea上运行WordCount程序</title>
      <link href="/2019/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8A%E8%BF%90%E8%A1%8CWordCount%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8A%E8%BF%90%E8%A1%8CWordCount%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="大数据学习"><a href="#大数据学习" class="headerlink" title="大数据学习"></a>大数据学习</h1><h2 id="–idea上运行WordCount程序"><a href="#–idea上运行WordCount程序" class="headerlink" title="–idea上运行WordCount程序"></a>–idea上运行WordCount程序</h2><blockquote><blockquote><p>环境：<br>idea：ultimate 2018.1</p></blockquote></blockquote><p>首先打开idea<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8A%E8%BF%90%E8%A1%8CWordCount%E7%A8%8B%E5%BA%8F/20190326111811050.png" alt><br>界面是这样的，我们新建项目，选择maven项目，project SDK选择自己的jdk根目录，直接next<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8A%E8%BF%90%E8%A1%8CWordCount%E7%A8%8B%E5%BA%8F/20190326111904421.png" alt><br>然后是组id和工件id，自己命名，然后next<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8A%E8%BF%90%E8%A1%8CWordCount%E7%A8%8B%E5%BA%8F/20190326112229603.png" alt><br>然后是项目名称和项目存放地址，然后finish<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8A%E8%BF%90%E8%A1%8CWordCount%E7%A8%8B%E5%BA%8F/20190326112503174.png" alt><br>进来项目主页，右下角会有提示，我们选择右边的<code>Enable Auto-Import</code>，这个是自动给我们导入包<br>我们先设置一下maven环境<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8A%E8%BF%90%E8%A1%8CWordCount%E7%A8%8B%E5%BA%8F/20190326113059444.png" alt><br><code>file-&gt;settings</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8A%E8%BF%90%E8%A1%8CWordCount%E7%A8%8B%E5%BA%8F/20190326113152411.png" alt><br>输入maven到这个页面，我们要修改的是下面两个<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8A%E8%BF%90%E8%A1%8CWordCount%E7%A8%8B%E5%BA%8F/20190327080718366.png" alt><br>第一个设置为maven安装的根目录<br>下面一个设置为<code>maven-&gt;conf-&gt;settings</code><br>然后在pom.xml文件里面添加一些代码<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8A%E8%BF%90%E8%A1%8CWordCount%E7%A8%8B%E5%BA%8F/20190327080859204.png" alt></p><pre><code>&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;            &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;            &lt;version&gt;2.6.1&lt;/version&gt;        &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>log4j是日志打印文件，可以将mapreduce的运行日志打印在控制台，hadoop-client是hadoop客户端，然后我们在src的java文件夹新建一个类，写入wordcount代码</p><pre><code>import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;import java.io.IOException;public class HadoopDriver {    public static class HadoopMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; {        private Text textKey = new Text();        private IntWritable count = new IntWritable();        @Override        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {            String[] words = value.toString().split(&quot;,&quot;);            for (String word : words) {                textKey.set(word);                count.set(1);                context.write(textKey, count);            }        }    }    public static class HadoopReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {        //相同的key聚合 几种类型的key调用reduce几次        private IntWritable count = new IntWritable();        @Override        protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException {            int sum = 0;            for (IntWritable value : values) {                sum += value.get();            }            count.set(sum);            context.write(key, count);        }    }    public static void main(String[] args) throws Exception {        Configuration config = new Configuration();        //把任务封装到job对象        Job job = Job.getInstance(config);        //        job.setJarByClass(HadoopDriver.class);        job.setMapperClass(HadoopMapper.class);        job.setReducerClass(HadoopReducer.class);        //指定map        // 如果map的输出和reduce输出key-value类型一致  可以不写map        job.setMapOutputKeyClass(Text.class);        job.setMapOutputValueClass(IntWritable.class);        //指定reducer        job.setOutputKeyClass(Text.class);        job.setOutputValueClass(IntWritable.class);        //告诉hadoop集群 以什么方式读取数据  从哪里读取        job.setInputFormatClass(TextInputFormat.class);        TextInputFormat.setInputPaths(job, new Path(&quot;D:\\word.txt&quot;));        //告诉hadoop集群以什么样的方式写入数据   数据写入到哪里        job.setOutputFormatClass(TextOutputFormat.class);        Path path = new Path(&quot;D:\\wordcount&quot;);        FileSystem fs = FileSystem.get(config);        if (fs.exists(path)) {            fs.delete(path, true);        }        TextOutputFormat.setOutputPath(job, path);        //提交任务        System.exit(job.waitForCompletion(true) ? 0 : 1);    }}</code></pre><p>这些包，maven会帮你自动下载，你只需要导入就行，计算机必须联网<br>我们来测试一下，在D盘创建word.txt文件，里面用<code>，</code>作为分隔符写字母<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8A%E8%BF%90%E8%A1%8CWordCount%E7%A8%8B%E5%BA%8F/20190419053340093.png" alt><br>然后我们运行wordcount程序<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8A%E8%BF%90%E8%A1%8CWordCount%E7%A8%8B%E5%BA%8F/20190327081628077.png" alt><br>运行结果如下，运行日志被打印出来了，可以看到运行成功，没有报错，我们来检查下统计结果，打开D盘，找到wordcount文件夹<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8A%E8%BF%90%E8%A1%8CWordCount%E7%A8%8B%E5%BA%8F/20190327081741092.png" alt><br>里面有4个文件，我们打开最后一个<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--idea%E4%B8%8A%E8%BF%90%E8%A1%8CWordCount%E7%A8%8B%E5%BA%8F/20190419053459546.png" alt><br>可以看到字母统计完成</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Idea </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习--Hive的安装与使用</title>
      <link href="/2019/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hive%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hive%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="大数据学习"><a href="#大数据学习" class="headerlink" title="大数据学习"></a>大数据学习</h1><h2 id="–Hive的安装与使用"><a href="#–Hive的安装与使用" class="headerlink" title="–Hive的安装与使用"></a>–Hive的安装与使用</h2><blockquote><blockquote><p>环境：<br>Hive：2.3.4<br>linux：centOS 6.7<br>VM：15.0.0<br>外部环境：windows 10家庭版<br>远程工具：SecureCRT</p></blockquote></blockquote><h3 id="Hive的安装"><a href="#Hive的安装" class="headerlink" title="Hive的安装"></a>Hive的安装</h3><p><a href="http://mirror.bit.edu.cn/apache/hive/hive-2.3.4/" target="_blank" rel="noopener">Hive下载链接</a><br>下载完成之后，通过远程工具上传到主机里面（略）<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hive%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190331122600668.png" alt><br>上传成功，然后解压缩到相应的目录<br><code>tar -xcvf apache-hive-2.3.4-bin.tar.gz</code><br>解压缩完成后，我们需要配置hive的环境变量<br><code>vim /etc/profile</code><br>进入这个文件，在文件尾加入</p><pre><code>export HIVE_HOME= &lt;hive根目录&gt;export PATH=$PATH:$HIVE_HOME/bin</code></pre><p><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hive%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190331123601806.png" alt><br>保存退出<br><code>source /etc/profile</code><br>使文件生效<br>然后验证是否配置成功<br><code>which hive</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hive%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190331124037464.png" alt><br>出现路径，说明配置成功<br>下一步，我们安装mysql，首先检查一下系统里有没有mysql，这一步需要网络，我们要设置虚拟机为桥接或者net模式<br><code>yum list installed|grep mysql</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hive%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190331125840674.png" alt><br>我的之前安装过，我们先卸载他重装一下<br>卸载<code>yum -y remove mysql.x86_64</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hive%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190331010028817.png" alt><br>卸载成功，重装<br><code>yum -y install mysql-server mysql mysql-devel</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hive%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190331010222060.png" alt><br>安装成功，我们看一下服务启动没有<br><code>service mysqld status</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hive%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190331010815220.png" alt><br>没有启动，我们启动一下，并且设置开机启动<br><code>chkconfig --level 35 mysqld on</code><br>然后我们先手动启动一下mysql服务<br><code>service mysqld start</code><br>通常情况下，新安装好的mysql不需要密码输入<strong>mysql</strong>就能登录，我们为了安全起见，要设置用户名和密码<br>进入/usr/bin目录，然后执行<br><code>ls|grep mysql</code><br>再执行<br><code>mysql_secure_installation</code><br>这个是给新安装的mysql配置用户名和密码的，我们设置一下<br>然后我们使用<br><code>mysql -&lt;用户名&gt; -p&lt;密码&gt;</code><br>就能登录mysql了<br>退出输入<code>exit</code>即可<br>接下来配置hive的文件，进入hive里面的conf目录<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hive%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190331124636570.png" alt><br>能看到hive-default.xml.template和hive-env.sh.template两个文件，我们需要拷贝然后改名字，这就是两个文件的副本，方便我们修改</p><pre><code>cp hive-default.xml.template hive-site.xmlcp hive-env.sh.template hive-env.sh</code></pre><p>然后我们来配置这两个文件</p><h4 id="hive-env-sh"><a href="#hive-env-sh" class="headerlink" title="hive-env.sh"></a>hive-env.sh</h4><p>我们只需要在里面加上hadoop的根目录就行<br><code>HADOOP_HOME=&lt;hadoop根目录&gt;</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hive%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190331014931333.png" alt></p><h4 id="hive-site-xml"><a href="#hive-site-xml" class="headerlink" title="hive-site.xml"></a>hive-site.xml</h4><p>加入</p><pre><code>      &lt;property&gt;        &lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt;        &lt;value&gt;/home/local/hive-metastore-dir/warehouse&lt;/value&gt;      &lt;/property&gt;    &lt;property&gt;      &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;      &lt;value&gt;jdbc:mysql://cbw:3306/hivedb?createDatabaseIfNotExist=true&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;      &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;      &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;      &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;      &lt;value&gt;root&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;      &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;      &lt;value&gt;123456&lt;/value&gt;&lt;/property&gt;</code></pre><p>其中<strong>hive.metastore.warehouse.dir</strong>和<strong>javax.jdo.option.ConnectionURL</strong>文件里面有，可用<code>/&lt;字符串&gt;</code>查找并且修改value为上面的值即可，然后修改主机名为自己的主机名<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hive%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190331015902175.png" alt><br>然后下载数据库驱动包<br><a href="https://dev.mysql.com/downloads/file/?id=484819" target="_blank" rel="noopener">https://dev.mysql.com/downloads/file/?id=484819</a><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hive%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190331020502326.png" alt><br>下载完成，上传驱动包到虚拟机<br>然后将驱动包移动到hive安装目录下的lib目录里面<br><code>mv mysql-connector /usr/hive/lib/</code><br>然后重启数据库<br><code>service mysqld restart</code><br>重新初始化元数据信息<br><code>./shematool -dbType mysql -initSchema</code></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习--Hadoop安装于配置</title>
      <link href="/2019/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="大数据学习"><a href="#大数据学习" class="headerlink" title="大数据学习"></a>大数据学习</h1><h2 id="–Hadoop安装与配置"><a href="#–Hadoop安装与配置" class="headerlink" title="–Hadoop安装与配置"></a>–Hadoop安装与配置</h2><blockquote><blockquote><p>环境：<br>jdk：1.8<br>hadoop：2.6.1<br>linux：centOS 6.7<br>VM：15.0.0<br>外部环境：windows 10家庭版<br>远程工具：SecureCRT</p></blockquote></blockquote><h3 id="1-网络环境配置"><a href="#1-网络环境配置" class="headerlink" title="1. 网络环境配置"></a>1. 网络环境配置</h3><p>因为我是处于学习阶段，所以使用vm虚拟机模拟大数据环境。设置3个服务器，选定一个作为主机。<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324110341507.png" alt><br>我选择第一个，也就是service01为主机。</p><h4 id="首先配置ip，将三个服务器ip设置到同一网段。"><a href="#首先配置ip，将三个服务器ip设置到同一网段。" class="headerlink" title="首先配置ip，将三个服务器ip设置到同一网段。"></a>首先配置ip，将三个服务器ip设置到同一网段。</h4><p>修改ip地址有两个方法，一个是修改文件，还有个是进入setup修改。</p><h5 id="通过文件修改："><a href="#通过文件修改：" class="headerlink" title="通过文件修改："></a>通过文件修改：</h5><p><code>vim /etc/sysconfig/network-scripts/ifcfg-eth8</code><br>输入以上命令进入eth8这块网卡，这个虚拟网卡是vm虚拟机自带的，还有一块eth0，我们使用哪一个都一样，只是一个名字。进入后我们可以看到以下界面：<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324111638299.png" alt><br>DEVICE=网卡名称<br>HWADDR=物理地址（硬件地址）<br>TYPE=网卡类型（可以设置成static，静态永久的）<br>UUID=是虚拟机自己设置的<br>ONBOOT=是否开机启动<br>IPADDR=ip地址，也就是我们要修改的<br>NETMASK=子网掩码<br>我们需要修改ip地址，将它的地址和我们自己的电脑，虚拟机的ip这3者的ip设置到同一网段内，另外两台同理，一样设置。</p><h5 id="通过setup界面修改："><a href="#通过setup界面修改：" class="headerlink" title="通过setup界面修改："></a>通过setup界面修改：</h5><p>直接输入<br><code>setup</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324112315705.png" alt><br>进入以上界面，选择第四个，network configuration<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324112414087.png" alt><br>选择第一个<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324112431091.png" alt><br>可以看到我们的eth8这块网卡，选择它<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324112457782.png" alt><br>这里我们可以直接修改网卡名和ip地址，修改完成后，save&amp;quit，然后执行<br><code>service network restart</code><br>重启网络服务，再次输入<br><code>ifconfig</code><br>查看，可以看到，ip已经修改了<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324112731303.png" alt></p><h4 id="下一步修改主机名，不然三个服务器的主机名默认都是root，这对后来设置域名映射时会很麻烦。"><a href="#下一步修改主机名，不然三个服务器的主机名默认都是root，这对后来设置域名映射时会很麻烦。" class="headerlink" title="下一步修改主机名，不然三个服务器的主机名默认都是root，这对后来设置域名映射时会很麻烦。"></a>下一步修改主机名，不然三个服务器的主机名默认都是root，这对后来设置域名映射时会很麻烦。</h4><p>我们输入下面的命令，进入network文件。<br><code>vim /etc/sysconfig/network</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324110702179.png" alt><br>里面的HOSTNAME就是你的主机名，默认是root，修改成自己的，然后ESC，shift+:,wq保存退出<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324110932243.png" alt><br>可以看到，主机名改变了</p><h3 id="2-域名映射，ssh免登陆设置"><a href="#2-域名映射，ssh免登陆设置" class="headerlink" title="2. 域名映射，ssh免登陆设置"></a>2. 域名映射，ssh免登陆设置</h3><p>为了以后使用ssh登录其他服务器方便，我们要做域名映射，不然，每次都是输入一串ip地址，太麻烦，我们要在hosts文件里面修改域名映射，按照上面的教程，我们应该已经将3台服务器的主机名都设置好了，我的是cbw，cbw1，cbw2.<br>输入<br><code>vim /etc/hosts</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324113356993.png" alt><br>进入hosts文件，直接换行，写ip地址，空格，主机名，3台服务器都设置，然后保存退出<br>使用ping测试一下是否能通。<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324113859060.png" alt><br>可以看到，我们直接ping名字也能ping通，说明设置成功。其他几台服务器一样设置，为了方便，我们采用分发的方式，直接将这个文件分发给另外两台服务器。<br><code>scp /etc/hosts cbw1:/etc/hosts</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324114141319.png" alt><br>分发成功，cbw2同理，我们去看看另一台服务器是否能ping域名ping通。<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324114249976.png" alt><br>可以看到，我通过cbw1直接ping主机cbw，是可以ping通的，说明文件分发成功，cbw2也通过相同的方式分发就行。<br>ssh免登陆设置：<br>我们使用ssh远程登录其他服务器的时候要输入密码，而因为hadoop的原因，有很多时候要多次登录其他服务器，每次都输入密码的话，很浪费时间和操作，而且我们使用hadoop的时候基本没有什么安全隐患，所有没必要设置每次都登录输入密码，这样会让操作变繁琐，因此我们要设置ssh免登陆。<br>先在root目录下查看是否有.ssh文件夹，如果没有的话就新建一个。<br>然后输入以下命令<br><code>ssh-keygen</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324115258041.png" alt><br>然后一直回车，直到出现一个图案<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324115350198.png" alt><br>这个时候代表获取密钥成功了，下一步，分发密钥给其他服务器<br><code>ssh-copy-id cbw1</code><br>然后它会提示你输入密码，输入密码之后就代表成功了，下次使用ssh命令进入cbw1时是不用输入密码的，同理，cbw2也配置一下，ssh免登陆设置成功。</p><h3 id="3-服务器配置jdk环境"><a href="#3-服务器配置jdk环境" class="headerlink" title="3. 服务器配置jdk环境"></a>3. 服务器配置jdk环境</h3><blockquote><blockquote><p>以下所说的jdk都是你自己下载的jdk压缩包名，或者解压后的jdk文件夹的名字，我自己的改名叫jdk，方便修改其他东西</p></blockquote></blockquote><p>首先下载好jdk<br><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">下载地址</a><br>要安装一种远程连接工具，xshell或secureCRT都行，我使用的是secureCRT，连接好主机后，使用alt+p调出sftp窗口<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324121414887.png" alt><br><code>put &lt;文件路径&gt;</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324121526986.png" alt><br>回车，上传jdk到服务器，然后查看root目录下，文件是否上传成功<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324121618909.png" alt><br>可以看到，jdk上传成功<br>再将jdk移动到/usr/文件夹下面<br><code>mv jdk /usr/</code><br>然后解压jdk<br><code>tar -xvzf jdk</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324122335603.png" alt><br>解压成功，可以看到有很多jar包。<br>接下来就是配置环境变量了，进入/etc/profile/文件<br><code>vim /etc/profile</code><br>跳到文件末尾，输入以下内容</p><pre><code>export JAVA_HOME=/usr/jdkexport JRE_HOME=/usr/jdk/jreexport PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</code></pre><p><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324122517876.png" alt><br>然后出去输入<br><code>source /etc/profile</code><br>刷新文件并保存，再输入<br><code>java -version</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324122947439.png" alt><br>如果出现以上信息，说明jdk环境已经搭建完毕<br>然后，我们使用scp命令，将jdk和环境配置文件分发到其他的两台服务器上面<br><code>scp -r /usr/jdk/ cbw1:/usr/jdk/</code><br><code>scp /etc/profile/ cbw1:/etc/profile/</code><br>cbw2同理，然后去到另外两台服务器source一下文件,重新加载并生效<br><code>source /etc/profile</code><br>此时，3台服务器的jdk都已经配置完毕</p><h3 id="4-服务器配置Hadoop环境"><a href="#4-服务器配置Hadoop环境" class="headerlink" title="4. 服务器配置Hadoop环境"></a>4. 服务器配置Hadoop环境</h3><p><a href="https://archive.apache.org/dist/hadoop/common/" target="_blank" rel="noopener">hadoop下载地址</a><br>找到相应版本下载即可<br>安装hadoop与jdk同理，上传hadoop压缩包，然后解压，然后放到/usr/里面，开始配置环境变量，进入/etc/profile/文件<br><code>vim /etc/profile</code><br>跳到文件末尾，输入以下内容</p><pre><code>export HADOOP_HOME=/usr/hadoop-2.6.1export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin</code></pre><p><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324102915221.png" alt><br>然后出去输入<br><code>source /etc/profile</code><br>刷新文件并保存，再输入<br><code>hadoop version</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324103209122.png" alt><br>如果出现以上画面，说明环境配置完毕</p><h3 id="5-Hadoop文件配置"><a href="#5-Hadoop文件配置" class="headerlink" title="5. Hadoop文件配置"></a>5. Hadoop文件配置</h3><p><code>cd /usr/hadoop2.6.1/etc/hadoop/</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324112142817.png" alt><br>进入这个文件夹，我们需要配置6个文件：</p><h4 id="hadoop-env-xml"><a href="#hadoop-env-xml" class="headerlink" title="hadoop-env.xml"></a>hadoop-env.xml</h4><p>这个文件用来配置jdk的根路径<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324111543938.png" alt><br><code>export JAVA_HOME=/usr/jdk</code><br>在文件末尾加入jdk的路径，保存退出</p><h4 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h4><p>输入<br><code>vim core-site.xml</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324113841647.png" alt><br>文件内容如上，我们使用默认的文件系统<strong>fs.defaultFS</strong>，我们需要修改的是<strong>fs.defaultFS</strong>的<strong>value</strong>，这个值是告诉文件系统他的老大在哪台服务器启动，也就是主机，我的自然是cbw，后面的<strong>9000</strong>是端口。下面的<strong>hadoop.tmp.dir</strong>是告诉系统，hadoop的源文件存放在哪个目录下，<strong>value</strong>就是我设置的目录，默认是在hadoop根目录下的<strong>hdpdata</strong>文件夹，如果没有这个文件夹，hdfs在格式化的时候会去自动创建这个文件夹。                                                                                 </p><h4 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h4><p>这个文件是配置上传文件的<strong>blocksize</strong>副本数的<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324114117205.png" alt><br><strong>value</strong>设置为多少，block的副本数就是多少，如果不设置，它默认是3个，这里我们设置为2个</p><h4 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h4><p>这个是配置mapreduce所使用的框架<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324114506643.png" alt><br>我们使用yarn框架</p><h4 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h4><p>这个文件配置yarn的主机和nodemanager的服务<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324114620907.png" alt><br><strong>yarn</strong>的主机我们当然选择cbw，然后nodemanager的<strong>value</strong>我们写mapreduce_shuffle</p><h4 id="slaves"><a href="#slaves" class="headerlink" title="slaves"></a>slaves</h4><p>这个文件时配置所有服务器的<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/20190324114941015.png" alt><br>我们加上所有的服务器域名<br>到这里，需要配置的文件已经全部完成<br>然后格式化<strong>hdfs</strong><br><code>hdfs namenode -format</code><br>格式化完毕，同理，我们要将hadoop文件夹分发给其他服务器，还有环境文件也要分发<br><code>scp -r /usr/hadoop2.6.1 cbw1:/usr/hadoop2.6.1</code><br><code>scp /etc/profile cbw1:/etc/profile</code><br>cbw2同理<br>然后别忘记保存生效<br><code>source /etc/profile</code><br>到这一步hadoop的配置就完成了</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习--HA（高可用性）</title>
      <link href="/2019/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--HA/"/>
      <url>/2019/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0--HA/</url>
      
        <content type="html"><![CDATA[<h1 id="大数据学习"><a href="#大数据学习" class="headerlink" title="大数据学习"></a>大数据学习</h1><h2 id="–HA"><a href="#–HA" class="headerlink" title="–HA"></a>–HA</h2><blockquote><blockquote><p>环境</p></blockquote></blockquote><h3 id="HA简介"><a href="#HA简介" class="headerlink" title="HA简介"></a>HA简介</h3><h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> HA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux学习随笔</title>
      <link href="/2019/04/18/Linux%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/"/>
      <url>/2019/04/18/Linux%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<h1 id="linux学习随笔"><a href="#linux学习随笔" class="headerlink" title="linux学习随笔"></a>linux学习随笔</h1><blockquote><blockquote><p>环境：<br>系统：centos 6.3<br>VM：15.0.0<br>外部环境：windows 10家庭版<br>远程工具：SecureCRT</p></blockquote></blockquote><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>命令<br><code>userdel &lt;用户名&gt;</code><br>今天做实验的时候，发现删除不了用户，原因可能是之前登录过，和root之间切来切去，虽然xiaoming这个用户的远程什么的都断开了，但是有线程还在运行<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Linux%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/20190404011814349.png" alt><br>这样我们可以强制删除<br><code>userdel -f &lt;用户名&gt;</code><br>这样可以强制删除，即使这个用户还在登录，或者其他用户在使用这个用户的home文件夹<br><code>userdel -fr &lt;用户名&gt;</code><br>加上<strong>r</strong>选项，可以在删除的时候讲home文件夹下面的用户目录一起删除<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Linux%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/20190404012048561.png" alt><br>home目录的xiaoming也没了<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Linux%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/20190404012119519.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习--JDK的下载与配置</title>
      <link href="/2019/04/18/Java%E5%AD%A6%E4%B9%A0--JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/04/18/Java%E5%AD%A6%E4%B9%A0--JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h1><h2 id="–JDK的下载与配置"><a href="#–JDK的下载与配置" class="headerlink" title="–JDK的下载与配置"></a>–JDK的下载与配置</h2><blockquote><blockquote><p>环境：<br>jdk:1.8<br>系统：windows10 家庭版</p></blockquote></blockquote><h3 id="JDK下载"><a href="#JDK下载" class="headerlink" title="JDK下载"></a>JDK下载</h3><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">下载地址</a><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Java%E5%AD%A6%E4%B9%A0--JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326031324146.png" alt><br>我们下载jdk1.8版本，windows x64的<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Java%E5%AD%A6%E4%B9%A0--JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326031528449.png" alt><br>下载完成后我们运行安装文件，开始安装之后，点击下一步<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Java%E5%AD%A6%E4%B9%A0--JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326032453469.png" alt><br>到达定制安装界面，我们修改一下安装位置就行，然后下一步<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Java%E5%AD%A6%E4%B9%A0--JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326032542742.png" alt><br>正在安装<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Java%E5%AD%A6%E4%B9%A0--JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326032748546.png" alt><br>确定<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Java%E5%AD%A6%E4%B9%A0--JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326032826119.png" alt><br>安装jre，修改安装路径，下一步<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Java%E5%AD%A6%E4%B9%A0--JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326033039868.png" alt><br>安装完成</p><h3 id="JDK环境配置"><a href="#JDK环境配置" class="headerlink" title="JDK环境配置"></a>JDK环境配置</h3><p>右键我的电脑-&gt;属性<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Java%E5%AD%A6%E4%B9%A0--JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326033220297.png" alt><br>左上角高级系统设置<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Java%E5%AD%A6%E4%B9%A0--JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326033254314.png" alt><br>右下角环境变量<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Java%E5%AD%A6%E4%B9%A0--JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326033330303.png" alt><br>在系统变量里面新建<strong>JAVA_HOME</strong>环境变量<br><code>JAVA_HOME= &lt;jdk安装根目录&gt;</code><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Java%E5%AD%A6%E4%B9%A0--JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326033922213.png" alt><br>然后向Path里面新建路径</p><pre><code>%JAVA_HOME%\bin%JAVA_HOME%\lib\tools.jar%JAVA_HOME%\lib\dt.jar</code></pre><p><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Java%E5%AD%A6%E4%B9%A0--JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326034149740.png" alt><br>然后打开电脑cmd终端，输入java和javac<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Java%E5%AD%A6%E4%B9%A0--JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326034655984.png" alt><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Java%E5%AD%A6%E4%B9%A0--JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E9%85%8D%E7%BD%AE/20190326034718377.png" alt><br>上面一个是java命令，下面一个是javac命令，如果两个命令都能行，说明java环境配置成功</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea的快捷键</title>
      <link href="/2019/04/18/Idea%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/04/18/Idea%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Idea的快捷键"><a href="#Idea的快捷键" class="headerlink" title="Idea的快捷键"></a>Idea的快捷键</h1><blockquote><blockquote><p>环境：<br>idea：ultimate 2018.1<br>系统：windows10 家庭版</p></blockquote></blockquote><h2 id="1-psvm"><a href="#1-psvm" class="headerlink" title="1.psvm"></a>1.psvm</h2><p>可以直接输出main方法</p><pre><code>    public static void main(String[] args) {    }</code></pre><h2 id="2-sout"><a href="#2-sout" class="headerlink" title="2.sout"></a>2.sout</h2><p>可以字节输出打印语句<br><code>System.out.println();</code><br>小技巧：<br>使用sout的时候，用变量.sout可以直接打印出输出语句，并将变量放在括号中</p><pre><code>s.soutSystem.out.println(s);</code></pre><h2 id="3-alt-Enter"><a href="#3-alt-Enter" class="headerlink" title="3.alt+Enter"></a>3.alt+Enter</h2><p>在需要导入包的变量上按，可以快速导入需要的包</p><h2 id="4-ctrl-alt-v"><a href="#4-ctrl-alt-v" class="headerlink" title="4.ctrl+alt+v"></a>4.ctrl+alt+v</h2><p>可以快速补全语句，如<br><code>new String();</code><br>可以快速补全为<br><code>String string = new String();</code></p><h2 id="5-alt-insert"><a href="#5-alt-insert" class="headerlink" title="5.alt+insert"></a>5.alt+insert</h2><p>可以快速插入构造器，getter和setter方法等</p><h2 id="6-ctrl-i"><a href="#6-ctrl-i" class="headerlink" title="6.ctrl+i"></a>6.ctrl+i</h2><p>可以快速实现该类所实现的接口的方法</p><h2 id="7-ctrl-shift-c"><a href="#7-ctrl-shift-c" class="headerlink" title="7.ctrl+shift+c"></a>7.ctrl+shift+c</h2><p>可以快速注释大片代码</p><h2 id="8-ctrl-shift-x"><a href="#8-ctrl-shift-x" class="headerlink" title="8.ctrl+shift+x"></a>8.ctrl+shift+x</h2><p>可以快速取消大片注释</p>]]></content>
      
      
      <categories>
          
          <category> Idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea打包jar包</title>
      <link href="/2019/04/18/Idea%E6%89%93jar%E5%8C%85/"/>
      <url>/2019/04/18/Idea%E6%89%93jar%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Idea打包jar包"><a href="#Idea打包jar包" class="headerlink" title="Idea打包jar包"></a>Idea打包jar包</h1><blockquote><blockquote><p>环境：<br>idea：ultimate 2018.1<br>系统：windows10 家庭版</p></blockquote></blockquote><p>1.先将代码修改成通用格式<br>一些常量修改为形参，如路径<br><code>Path path = new Path(&quot;D:\\test.txt&quot;);</code><br>可以修改为<br><code>Path path = new Path(args[0]);</code><br>2.修改完毕我们可以开始打包<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Idea%E6%89%93jar%E5%8C%85/20190409040343424.png" alt><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Idea%E6%89%93jar%E5%8C%85/20190409040503623.png" alt><br><strong>File</strong>-&gt;<strong>Project Structure</strong>-&gt;<strong>Artifacts</strong>-&gt;<strong>+号</strong>-&gt;<strong>JAR</strong>-&gt;<strong>From modules with dependencies</strong><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Idea%E6%89%93jar%E5%8C%85/20190409041019553.png" alt><br>在Main Class中找到自己要打包的class<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Idea%E6%89%93jar%E5%8C%85/20190409041214894.png" alt><br>下面那个是元数据信息，我们可以默认目录，也可以自己选择，然后<strong>ok</strong><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Idea%E6%89%93jar%E5%8C%85/20190409041904186.png" alt><br>这个目录是之后方jar包的目录，我们可以选择到自己项目的目录，方便查找，然后Apply，ok<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Idea%E6%89%93jar%E5%8C%85/20190409042256223.png" alt><br>之后我们点击Build-&gt;Build Artifacts<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Idea%E6%89%93jar%E5%8C%85/20190409042324094.png" alt><br>点击Build<br>这个时候我们进入刚刚设置的存放jar包的目录<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/Idea%E6%89%93jar%E5%8C%85/20190409043044229.png" alt><br>可以发现打包成功</p>]]></content>
      
      
      <categories>
          
          <category> Idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++学习--运算符重载</title>
      <link href="/2019/04/18/c++%E5%AD%A6%E4%B9%A0--%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2019/04/18/c++%E5%AD%A6%E4%B9%A0--%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="c-学习"><a href="#c-学习" class="headerlink" title="c++学习"></a>c++学习</h1><h2 id="–运算符重载"><a href="#–运算符重载" class="headerlink" title="–运算符重载"></a>–运算符重载</h2><blockquote><blockquote><p>环境：<br>codeblocks：17.12<br>系统：windows10 家庭版</p></blockquote></blockquote><p><strong>输入输出运算符重载，只能重载成友元函数</strong></p><h3 id="输出运算符重载"><a href="#输出运算符重载" class="headerlink" title="输出运算符重载"></a>输出运算符重载</h3><p>通常情况下，输出符只能直接输出标准类型的值，而我们自定义类型是不能直接输出的<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/c%2B%2B%E5%AD%A6%E4%B9%A0--%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/20190403101633233.png" alt><br>cout返回值为cout<br>cout &lt;&lt; p1 返回值还是cout，因为可以继续加&lt;&lt;输出</p><p>我们在Person对象中声明ostream友元函数<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/c%2B%2B%E5%AD%A6%E4%B9%A0--%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/20190403102842442.png" alt><br><code>friend ostream&amp; operator&lt;&lt;(ostream &amp;outPut,const Person &amp;p);</code><br>然后函数体</p><pre><code>ostream&amp; operator&lt;&lt;(ostream &amp;outPut,const Person &amp;p){    outPut &lt;&lt; p.name &lt;&lt; &quot;-&quot; &lt;&lt; p.address;    return outPut;}</code></pre><p>这个时候我们再去输出p1试试<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/c%2B%2B%E5%AD%A6%E4%B9%A0--%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/20190403103019718.png" alt><br>这个时候可以发现，cout可以直接输出我们的自定义类型</p><h3 id="输入运算符重载"><a href="#输入运算符重载" class="headerlink" title="输入运算符重载"></a>输入运算符重载</h3><p>正常情况下<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/c%2B%2B%E5%AD%A6%E4%B9%A0--%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/20190403112257231.png" alt><br>这样是不行的，不能直接给自定义类型输入值，但是我们重载输入运算符就能自己自定义</p><pre><code>声明：   friend istream&amp; operator&gt;&gt;(istream &amp;inPut, Person &amp;p)函数体istream&amp; operator&gt;&gt;(istream &amp;inPut, Person &amp;p){    p.address = new char[10];    inPut &gt;&gt; p.name &gt;&gt; p.address;    return inPut;}</code></pre><p>测试一下<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/c%2B%2B%E5%AD%A6%E4%B9%A0--%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/20190403020543413.png" alt><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/c%2B%2B%E5%AD%A6%E4%B9%A0--%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/20190403020612308.png" alt><br>重载成功</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++学习--类型重载</title>
      <link href="/2019/04/18/c++%E5%AD%A6%E4%B9%A0--%E7%B1%BB%E5%9E%8B%E9%87%8D%E8%BD%BD/"/>
      <url>/2019/04/18/c++%E5%AD%A6%E4%B9%A0--%E7%B1%BB%E5%9E%8B%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="c-学习"><a href="#c-学习" class="headerlink" title="c++学习"></a>c++学习</h1><h2 id="–类型重载"><a href="#–类型重载" class="headerlink" title="–类型重载"></a>–类型重载</h2><blockquote><blockquote><p>环境：<br>codeblocks：17.12<br>系统：windows10 家庭版</p></blockquote></blockquote><p>正常情况下，同一个类型变量只能给同一个类型变量赋值，如果想要夸数据类型赋值，这个时候就需要类型重载，我们用成员函数的方式实现<br>我们定义一个<strong>Time</strong>类，然后有</p><pre><code>hour   小时minute 分second 秒</code></pre><p>然后我们将他赋值给<strong>float</strong>类型，让他将所有时间都换成秒。<br>格式如下</p><pre><code>声明：    operator &lt;类型&gt;()函数体：    &lt;类名&gt;::operator &lt;类型&gt;()    {    }</code></pre><p>实例代码</p><pre><code>#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;class Time{private:    int hour, minute,second;public :    Time(int hour, int minute, int second);    void print();    operator float();};Time::Time(int hour,int minute, int second){    this-&gt;hour = hour;    this-&gt;minute = minute;    this-&gt;second = second;}void Time::print(){    cout &lt;&lt;&quot;小时:&quot; &lt;&lt; this-&gt;hour &lt;&lt; endl;    cout &lt;&lt;&quot;分:&quot; &lt;&lt; this-&gt;minute &lt;&lt; endl;    cout &lt;&lt;&quot;秒:&quot; &lt;&lt; this-&gt;second &lt;&lt; endl;}Time::operator float(){    float tamp;    tamp = hour * 3600 + minute * 60 + second;    return tamp;}int main(void){    Time t1(23,30,55);    t1.print();    float f = t1;    cout &lt;&lt; f;    getchar();    return 0;}</code></pre><p>结果<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/c%2B%2B%E5%AD%A6%E4%B9%A0--%E7%B1%BB%E5%9E%8B%E9%87%8D%E8%BD%BD/20190403114204303.png" alt><br>可以看到，float型的f成功赋值</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Questions</title>
      <link href="/2019/04/18/%E9%97%AE%E9%A2%98/"/>
      <url>/2019/04/18/%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E9%97%AE%E9%A2%98/20190409055541933.png" alt><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E9%97%AE%E9%A2%98/20190409055551124.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> questions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> questions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络连接的三种模式</title>
      <link href="/2019/04/18/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/18/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="网络连接的三种模式"><a href="#网络连接的三种模式" class="headerlink" title="网络连接的三种模式"></a>网络连接的三种模式</h1><blockquote><blockquote><p>环境<br>系统：windows10 家庭版<br>linux系统：centos 6.3<br>vm：15.0.3</p></blockquote></blockquote><pre><code>vm自带有3块网卡vmnet0：桥接模式vmnet1：仅主机模式vmnet8：NET模式我们可以打开编辑-&gt;虚拟网络编辑器，里面查看是否有这3块网卡，没有的话，我们可以自行增加</code></pre><p><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190417090323800.png" alt><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190417090438696.png" alt></p><h3 id="1-仅主机模式"><a href="#1-仅主机模式" class="headerlink" title="1.仅主机模式"></a>1.仅主机模式</h3><p>这个模式我们只需要修改虚拟机的连接模式为仅主机模式，设置vm与主机ip在同一个网段，然后将虚拟机ip也设置在同一网段即可。这个时候，我们用主机ping虚拟机，如果能ping通就说明设置成功</p><h5 id="a-查看主机ip"><a href="#a-查看主机ip" class="headerlink" title="a.查看主机ip"></a>a.查看主机ip</h5><p><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190417093745677.png" alt></p><h5 id="b-设置vm的仅主机模式网卡ip"><a href="#b-设置vm的仅主机模式网卡ip" class="headerlink" title="b.设置vm的仅主机模式网卡ip"></a>b.设置vm的仅主机模式网卡ip</h5><p><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190417090910233.png" alt></p><h5 id="c-设置虚拟机连接模式为仅主机模式"><a href="#c-设置虚拟机连接模式为仅主机模式" class="headerlink" title="c.设置虚拟机连接模式为仅主机模式"></a>c.设置虚拟机连接模式为仅主机模式</h5><p>右键点击虚拟机标签<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190417091153136.png" alt><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190417091301956.png" alt></p><h5 id="d-设置虚拟机的ip"><a href="#d-设置虚拟机的ip" class="headerlink" title="d.设置虚拟机的ip"></a>d.设置虚拟机的ip</h5><p>有两种方式，一种是<code>setup</code>命令，到图形界面设置，还有一个是通过文件设置，这里我们都采取文件设置。<br>首先我们进入<code>network-scripts</code>目录查看我们的虚拟网卡，这个是vm配置的<br><code>ls /etc/sysconfig/network-scripts</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190417091900672.png" alt><br>我们可以看到，有个<code>ifcfg-eth0</code>，这就是一块叫eth0的网卡，我们使用<code>ifconfig</code>命令查看网卡是否在使用<br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190417092033945.png" alt><br>这里已经在使用了<br>如果这里没有看到虚拟网卡，只有localhost的话，我们可以使用<code>ifup &lt;虚拟网卡名称&gt;</code>，这个命令启用网卡，比如我就是用<code>ifup eth0</code>，同理，使用<code>ifdown &lt;虚拟网卡名称&gt;</code>，停用网卡，这里不再赘述<br>修改ip，我们使用进入ifcfg-eth0文件<br><code>vim /etc/sysconfig/network-scripts/ifcfg-eth0</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190417092505604.png" alt><br>我们将这个ip修改为<code>192.168.43.253</code>，保存退出，最后一步<br><code>service network restart</code></p><h5 id="e-测试"><a href="#e-测试" class="headerlink" title="e.测试"></a>e.测试</h5><p>主机ping<code>192.168.43.253</code><br><img src="https://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190417092752075.png" alt><br>可以ping通，仅主机模式设置成功<br>如果以上步骤都完成了<br>虚拟机ping不通主机是因为主机有防火墙， 关闭防火墙也能ping通<br>主机ping不通虚拟机，虚拟机防火墙没有关闭</p><hr><h3 id="2-桥接模式"><a href="#2-桥接模式" class="headerlink" title="2.桥接模式"></a>2.桥接模式</h3><p>这个模式我们需要将虚拟机设置为桥接模式，然后修改虚拟机的<strong>网关</strong>和<strong>子网掩码</strong>，和主机正在使用且联网的那块网卡一致，再修改ip地址到同一网段即可</p><h5 id="a-查看主机ip-1"><a href="#a-查看主机ip-1" class="headerlink" title="a.查看主机ip"></a>a.查看主机ip</h5><p><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190418062916493.png" alt></p><h5 id="b-修改虚拟机为桥接模式"><a href="#b-修改虚拟机为桥接模式" class="headerlink" title="b.修改虚拟机为桥接模式"></a>b.修改虚拟机为桥接模式</h5><p><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190418062252478.png" alt><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190418062356772.png" alt></p><h5 id="c-修改虚拟机ip信息"><a href="#c-修改虚拟机ip信息" class="headerlink" title="c.修改虚拟机ip信息"></a>c.修改虚拟机ip信息</h5><p><code>vim /etc/sysconfig/network-scripts/ifcfg-eth0</code><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190418063122341.png" alt></p><pre><code>设置子网掩码：255.255.255.0默认网关：192.168.43.1</code></pre><p>改完别忘记<code>service network restart</code></p><h5 id="d-测试"><a href="#d-测试" class="headerlink" title="d.测试"></a>d.测试</h5><p>我们直接ping<code>baidu.com</code><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190418063742666.png" alt><br>如果可以ping通，代表桥接模式设置成功</p><h3 id="3-NET模式"><a href="#3-NET模式" class="headerlink" title="3.NET模式"></a>3.NET模式</h3><p>这个模式只需要将虚拟机设置为NET模式，设置虚拟机和vm的子网掩码和网关一致，再修改ip为同一网段即可，不用管主机ip</p><h5 id="a-设置vmip信息"><a href="#a-设置vmip信息" class="headerlink" title="a.设置vmip信息"></a>a.设置vmip信息</h5><p><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190418065205550.png" alt><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190418065608463.png" alt><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190418070914844.png" alt><br>这里网关最后一位应为2，因为他是物理机虚拟出来的一个网络，物理机上面的vmnet8这块网卡的网关是不一样的<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190418071045037.png" alt></p><h5 id="b-修改虚拟机为NET模式"><a href="#b-修改虚拟机为NET模式" class="headerlink" title="b.修改虚拟机为NET模式"></a>b.修改虚拟机为NET模式</h5><p><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190418064306987.png" alt><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190418064454848.png" alt></p><h5 id="c-修改虚拟机ip信息-1"><a href="#c-修改虚拟机ip信息-1" class="headerlink" title="c.修改虚拟机ip信息"></a>c.修改虚拟机ip信息</h5><p><code>vim /etc/sysconfig/network-scripts/ifcfg-eth0</code><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190418065721214.png" alt></p><pre><code>设置子网掩码：255.255.255.0默认网关：192.168.255.2ip：192.168.255.253</code></pre><p>改完别忘记<code>service network restart</code></p><h5 id="d-测试-1"><a href="#d-测试-1" class="headerlink" title="d.测试"></a>d.测试</h5><p>我们直接ping<code>baidu.com</code><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/20190418071149212.png" alt><br>如果可以ping通，代表NET模式设置成功</p>]]></content>
      
      
      <categories>
          
          <category> NetWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NetWork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux--webmin的安装与使用</title>
      <link href="/2019/04/06/lilux%E7%9B%B8%E5%85%B3/linux--webmin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/04/06/lilux%E7%9B%B8%E5%85%B3/linux--webmin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h2 id="–webmin的安装与使用"><a href="#–webmin的安装与使用" class="headerlink" title="–webmin的安装与使用"></a>–webmin的安装与使用</h2><blockquote><blockquote><p>环境：<br>webmin:1.900</p></blockquote></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://sourceforge.net/projects/webadmin/files/webmin/1.900/" target="_blank" rel="noopener">webmin下载链接</a><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/linux--webmin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190406122837265.png" alt><br>下载tar.gz包，上传到linux系统<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/linux--webmin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190406123059569.png" alt><br>第一个，第二个是轻量的<br><strong>开始安装</strong><br>1.解压缩<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/linux--webmin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190406123304374.png" alt><br>2.进入解压后的webmin文件目录，执行setup.sh脚本安装<br><code>./setup.sh</code><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/linux--webmin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190406123435885.png" alt><br>配置文件目录，回车<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/linux--webmin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190406123456619.png" alt><br>配置日志目录，回车<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/linux--webmin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190406123627147.png" alt><br>配置perl语言的完整目录，回车<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/linux--webmin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190406123647558.png" alt><br>配置端口，回车<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/linux--webmin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190406123710525.png" alt><br>配置登录用户名，回车，默认admin<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/linux--webmin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190406123727338.png" alt><br>配置密码，配置一下，回车，安装完成<br><strong>webmin的配置文件</strong><br><code>/etc/webmin/miniserv.conf</code><br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/linux--webmin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190406124600510.png" alt><br>修改密码<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/linux--webmin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190406010221787.png" alt><br><code>/root/webmin-1.900/changepass.pl /etc/webmin/ admin 000000</code><br>这里<code>/root/webmin-1.900/changepass.pl</code>是解压目录<br><code>/etc/webmin/</code>是安装之后的配置目录<br><code>admin</code>是你要修改的用户的用户名<br><code>000000</code>替换你这个用户的密码<br>如果你连用户都忘了<br><code>vim /etc/webmin/miniserv.users</code><br>进入这个配置文件，可以看到用户名<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/linux--webmin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190406010617820.png" alt><br><strong>卸载</strong><br><code>/etc/webmin/uninstall.sh</code></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>我们打开浏览器，注意它只支持部分浏览器，ie的不支持，使用ie内核的浏览器也不支持，我之前就是用360结果不行，然后换了火狐就好了<br>输入<br><code>http://localhost:10000</code><br>这个10000端口就是我们安装的时候默认的<br>注意这个<strong>localhost</strong>，你如果是用自己电脑安装的，可以直接用localhost，但是你如果使用的虚拟机，在虚拟机的linux中安装的webmin，那么localhost应该换成虚拟机的ip地址<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/linux--webmin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190406011125046.png" alt><br>我们输入用户名和密码<br><img src="http://cbw-1258890494.cos.ap-chengdu.myqcloud.com/linux--webmin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/20190406011152227.png" alt><br>登录成功，可以开始使用了</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> webmin </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
